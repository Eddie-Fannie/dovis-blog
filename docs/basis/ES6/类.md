# ES6中的class基本语法及继承

**ES5的继承可以参考之前的文章：[继承](/basis/JavaScript/继承)**

> ES6的class可以看作是一个语法糖，因为绝大部分功能ES5都能实现。新的class写法只是让对象原型的写法更加清晰，更像面向对象变成的语法而已。（所以类class相当于原型对象）

ES5构造函数创建新对象：
```js
function Point(x, y) {
    this.x = x;
    this.y = y;
}
Point.prototype.toString = function () {
    return '(' + this.x + ',' + this.y + ')'
}

var p = new Point(x, y)
```
用类的语法重写：
```js
class Point {
    constructor(x, y) {
        this.x = x; // this代表实例对象
        this.y = y;
    } // 构造方法
    toString() {
        return '(' + this.x + ',' + this.y + ')'
    } // 方法之间不需要加逗号分隔，会报错
}

type of Point // function 类的数据类型就是函数
Point === Point.prototype.constructor // true
```
## constructor方法
> 类的默认方法，通过`new`命令生成的对象实例时自动调用该方法。一个类必须有默认方法。

> `constructor`方法默认返回实例对象（this），不过完全可以指定返回另外一个对象。
```js
class Foo {
    constructor () {
        return Object.create(null);
    }
}
```
这样子就导致实例对象不是Foo类的实例
```js
new Foo() instanceof Foo // false
```

## 与构造函数相同的地方
1. ES5的构造函数Point对应ES6的Point类的构造方法。使用类的时候也是像构造函数一样直接使用`new`操作符即可。
2. 类的所有方法都定义在类的`prototype`属性上。所以上述例子如同：
```js
Point.prototype = {
    constructor() {},
    toString() {},
    toValue() {}
}
```
3. 与ES5一样，实例的属性除非显式定义在本身，即this对象上，否则都是定义在原型即(class)上。
4. 与ES5一致类的所有实例共享一个原型对象
```js
var p1 = new Point(2, 3);
var p2 = new point(3, 2);

P1.__proto__ === p2.__proto__ // true
```

**在类的实例上调用方法，其实就是调用原型上的方法**
```js
class B {}
let b = new B();

b.constructor === B.prototype.constructor // true
```

**类的所有方法，除构造方法之外都定义在`prototype`对象上，所以类的新方法可以添加在该对象上。利用`Object.assign()`**

## 与ES5行为不一致的地方
1. 类的内部定义的所有方法都是不可枚举的，这一点和ES5的行为不一致
```js
Object.keys(Point.prototype) // []
```
2. 类的属性名可以采用表达式
```js
let methodName = 'getArea';

class Square {
    constructor(length) {

    }
    [methodName] () {

    }
}
```
3. 类和模块内部默认使用严格模式
4. 类必须使用new来调用，不然会报错。普通构造函数是不一定需要。
5. typeof下类为function，而原型对象为object。虽然function也是特殊的object

