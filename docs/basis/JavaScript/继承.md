# 继承
>ECMAScript只支持实现继承，主要依靠原型链来实现。基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。

**如果让原型对象等于另一个类型的实例，结果会怎样呢？**
>此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。
```javascript
function APro() {

}
APro.prototype.a = 5;
function BPro() {

}
BPro.prototype.b = 10;
APro.prototype = new BPro(); //APro继承了BPro
console.log(APro.prototype.b) // 10
a1 = new APro();

console.log(a1.b) //10
```

**所有的引用类型默认继承Object，而这个继承也是通过原型链实现的**
>在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向`Object.prototype`。这也是所有自定义类型都会继承`toString()，valueOf()`等默认方法的原因。

**默认方法**
```javascript
let newObj = new Object()
console.log(Object.getPrototypeOf(newObj))
```

![img](/dovis-blog/js/4.png)

## 确定原型和实例的关系
1. instanceof操作符。
2. isPorototypeOf()方法。只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型。因此该方法会返回true