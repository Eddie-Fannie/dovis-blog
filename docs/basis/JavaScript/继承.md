# 继承
>ECMAScript只支持实现继承，主要依靠原型链来实现。基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。

**如果让原型对象等于另一个类型的实例，结果会怎样呢？**
>此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。
```javascript
function APro() {

}
APro.prototype.a = 5;
function BPro() {

}
BPro.prototype.b = 10;
APro.prototype = new BPro(); //APro继承了BPro
console.log(APro.prototype.b) // 10
a1 = new APro();

console.log(a1.b) //10
```

**所有的引用类型默认继承Object，而这个继承也是通过原型链实现的**
>在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向`Object.prototype`。这也是所有自定义类型都会继承`toString()，valueOf()`等默认方法的原因。

**默认方法**
```javascript
let newObj = new Object()
console.log(Object.getPrototypeOf(newObj))
```

![img](/dovis-blog/js/4.png)

## 确定原型和实例的关系
1. instanceof操作符。
2. isPorototypeOf()方法。只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型。因此该方法会返回true

## 谨慎定义方法
子类型有时候需要覆盖超类型中的某个方法，或者需要添加超类型不存在的某个方法。但不管怎么样，给原型添加方法的代码一定要放在替换原型语句之后。

```javascript
function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function () {
    return this.property
}

function SubType() {
    this.subproperty = false;
}

//继承了SuperType 替换原型语句
SubType.prototype = new SuperType();

//添加新方法
SubType.prototype.getSubValue = function () {
    return this.subproperty;
}
//重写超类型方法
SubType.prototype.getSuperValue = function () {
    return false;
}
var instance = new SubType();
console.log(instance.getSuperValue()) // false
console.log(instance.getSubValue()) // false

var test = new SuperType()
console.log(test.getSuperValue()) //true
```
> 如果把`SubType`的新方法getSubValue语句添加在替换原型语句之前，那么重写的超类型方法语句将会覆盖掉这个新方法，导致第二个`console`会打印出`instance.getSubValue is not a function`