# 继承
>ECMAScript只支持实现继承，主要依靠原型链来实现。基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。

**如果让原型对象等于另一个类型的实例，结果会怎样呢？**
>此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。
```javascript
function APro() {

}
APro.prototype.a = 5;
function BPro() {

}
BPro.prototype.b = 10;
APro.prototype = new BPro(); //APro继承了BPro
console.log(APro.prototype.b) // 10
a1 = new APro();

console.log(a1.b) //10
```

**所有的引用类型默认继承Object，而这个继承也是通过原型链实现的**
>在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向`Object.prototype`。这也是所有自定义类型都会继承`toString()，valueOf()`等默认方法的原因。

**默认方法**
```javascript
let newObj = new Object()
console.log(Object.getPrototypeOf(newObj))
```

![img](/dovis-blog/js/4.png)

## 确定原型和实例的关系
1. instanceof操作符。
2. isPorototypeOf()方法。只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型。因此该方法会返回true

## 谨慎定义方法
子类型有时候需要覆盖超类型中的某个方法，或者需要添加超类型不存在的某个方法。但不管怎么样，给原型添加方法的代码一定要放在替换原型语句之后。

```javascript
function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function () {
    return this.property
}

function SubType() {
    this.subproperty = false;
}

//继承了SuperType 替换原型语句
SubType.prototype = new SuperType();

//添加新方法
SubType.prototype.getSubValue = function () {
    return this.subproperty;
}
//重写超类型方法
SubType.prototype.getSuperValue = function () {
    return false;
}
var instance = new SubType();
console.log(instance.getSuperValue()) // false
console.log(instance.getSubValue()) // false

var test = new SuperType()
console.log(test.getSuperValue()) //true
```
> 如果把`SubType`的新方法getSubValue语句添加在替换原型语句之前，那么重写的超类型方法语句将会覆盖掉这个新方法，导致第二个`console`会打印出`instance.getSubValue is not a function`
**添加新方法的时候不能使用对象字面量创建原型方法，这样就会重写原型链。**

## 原型链的问题
>1. 包含引用类型值的原型属性会被所有实例共享；这也是为什么要在构造函数中，而不是在原型对象中定义属性的原因。
>2. 在创建子类型的实例时，不能向超类型的构造函数传递参数。
```javascript
function SuperType () {
    this.colors = ['red', 'blue', 'green'];
}
function SubType() {

}
SubType.prototype = new SuperType()
var instance1 = new SubType()
instance1.colors.push('black');
console.log(instance1.colors); // ["red", "blue", "green", "black"]

var instance2 = new SubType()
console.log(instance2.colors)// ["red", "blue", "green", "black"]
```
**修改后就能反映出实例共享引用类型值的原型属性这一种现象**<br/>
```javascript
function SuperType () {
    this.colors = 4;
}
function SubType() {

}
SubType.prototype = new SuperType()
var instance1 = new SubType()
instance1.colors = 5;
console.log(instance1.colors); // 5

var instance2 = new SubType()
console.log(instance2.colors)// 4
```
因为数值类型不是引用类型，所以就不会共享。
