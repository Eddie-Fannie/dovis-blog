# 对象的深浅拷贝

> 基本数据类型数据存储在栈中；引用数据类型存储的是该对象在栈中的引用，真实的数据存放在堆内存里。

- 浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的是基本类型的值，如果属性是引用类型则拷贝的是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象（逐个成员拷贝）。

- 深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响到原来的对象。

## 赋值和深浅拷贝的区别
- 赋值：当新建一个变量然后赋值一个对象给它时，赋的其实的对象在栈中的地址，而不是堆中的数据，这样两个对象共用一份地址，所以两个对象就联动了。切忌误以为这是浅拷贝。**啥数据类型的属性都受影响**
```js
var obj1 = {
    name: 'linjiaheng',
    language: ['vue', 'ts', 'js']
}
var obj2 = obj1
console.log(obj2 === obj1)
obj2.name = 'xielin';
obj2.language[2] = 'React';
console.log(obj2)
console.log(obj1)
```
![img](/dovis-blog/js/copy.png)

- 浅拷贝：拷贝后对象的基本数据类型不受影响，引用类型因为共用一块内存所以互相影响。**基本数据类型不受影响**
```js
// 浅拷贝
var obj1 = {
    name: 'linjiaheng',
    language: ['vue', 'ts', 'js']
}
var obj3 = shallowCopy(obj1);
obj3.name = "lisi";
obj3.language[3] = 'nuxt';
function shallowCopy(src) {
var dst = {};
for (var prop in src) {
    if (src.hasOwnProperty(prop)) {
        dst[prop] = src[prop];
    }
}
    return dst;
}
console.log('obj1',obj1)
console.log('obj3',obj3)
```
![img](/dovis-blog/js/copy1.png)

- 深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。
```js
function deepClone(obj) {
    var newObj = obj instanceof Array ? []:{}; // 考虑数组
    if(typeof obj !== 'object') {
        return obj;
    } else {
        for(var i in obj) {
            newObj[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i];
        }
    }
    return newObj;
}
```

## 浅拷贝实现方式
1. `Object.assign()`
> 针对深拷贝，需要使用其他方法，因为`Object.assign()`拷贝的是可枚举属性值。假如源值是一个对象的引用，它仅仅会复制其引用值。

**例子：**
```js
const log = console.log;
function test() {
    let obj1 = { a: 0 , b: { c: 0}}; 
    let obj2 = Object.assign({}, obj1); 
    log(JSON.stringify(obj2));
    // { a: 0, b: { c: 0}} 

    obj1.a = 1; 
    log(JSON.stringify(obj1));
    // { a: 1, b: { c: 0}} 
    log(JSON.stringify(obj2));
    // { a: 0, b: { c: 0}} 

    obj2.a = 2; 
    log(JSON.stringify(obj1));
    // { a: 1, b: { c: 0}} 
    log(JSON.stringify(obj2));
    // { a: 2, b: { c: 0}}

    obj2.b.c = 3; 
    log(JSON.stringify(obj1));
    // { a: 1, b: { c: 3}} 
    log(JSON.stringify(obj2));
    // { a: 2, b: { c: 3}}

    // Deep Clone 
    obj1 = { a: 0 , b: { c: 0}}; 
    let obj3 = JSON.parse(JSON.stringify(obj1)); 
    obj1.a = 4; 
    obj1.b.c = 4; 
    log(JSON.stringify(obj3));
    // { a: 0, b: { c: 0}}
}
test()
```

2. `Array.prototype.concat()`
```js
let arr = [1, 3, {
    username: 'kobe'
}];
let arr2=arr.concat();    
arr2[2].username = 'wade';
console.log(arr);
```
![img](/dovis-blog/js/copy3.png)

3. `Array.prototype.slice()`
4. 展开运算符
```js
let obj1 = { name: 'Kobe', address:{x:100,y:100}}
let obj2= {... obj1}
obj1.address.x = 200;
obj1.name = 'wade'
console.log('obj2',obj2) // obj2 { name: 'Kobe', address: { x: 200, y: 100 } }
```

## 深拷贝实现方式
1. `JSON.parse(JSON.stringify())`
> 这也是利用`JSON.stringify`将对象转成JSON字符串，再用`JSON.parse`把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。

> 这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则，因为这两者基于JSON.stringify和JSON.parse处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为null）了。

2. 手写递归
> 递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝。