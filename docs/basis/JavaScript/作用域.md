# JS的作用域，作用域链，闭包

## 变量
> 复制保存着对象的某个变量时，操作的是对象的引用。为对象添加属性时，操作的是该对象本身。

> 1. 如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配到位置上。
> 2. 从一个变量向另一个变量复制引用类型到值，同样也会将存储在变量对象中值复制一份放到新变量 分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个小对象。

1. 如果初始化变量没有使用`var`声明，该变量会自动被添加到全局环境。
2. 基本数据类型的内存占据固定大小的空间，因此被保存在栈内存中。

## 作用域（scope）

> 作用域 规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。（规定变量和函数的可使用范围叫做作用域）

> 块语句，如`if,switch,for,while`等循环语句，不像函数，它们不会创建一个新的作用域。
```js
var name = 'linjiaheng'
function sayName() {
    var age = 18;
    if(name === 'linjiaheng') {
        var sex = 'male'
    }
    console.log(sex) // male
}
sayName()
```

1. 词法作用域
> 简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你写代码时将变量和作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。

2. 动态作用域
> 在JS里，动态作用域和`this`机制息息相关。
```js
var a = 1;
function foo() {
    var a = 2;
    console.log(this.a) // 1  这个this指向全局对象Window
}
foo()
```
从上面的例子中可以看出结果不是取之于写代码的位置，而是取决于函数执行的位置。

::: tip
+ 词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。
+ 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。
:::

3. 块作用域
+ `try...catch`语句中`catch`语句会创建一个块作用域，`catch`的参数变量仅在`catch`内部有效。
+ 利用ES6的`let，const`关键字定义变量也会隐式创建块作用域。
+ `with`语句声明中

::: warning
许多开发人员经常混淆作用域和执行上下文（执行环境），误认为是一样的概念。Javascript的执行分为：解释和执行两个阶段。

**解释阶段：**
- 词法分析
- 语法分析
- 作用域规则确定

**执行阶段：**
- 创建执行上下文（例如this的指向）
- 执行函数代码
- 垃圾回收

每当有函数执行时就会产生一个新的上下文，这一上下文会被压入JS上下文堆栈（context stack）中，函数执行结束后则被弹出。

> 执行上下文（包括变量对象、作用域链、`this`的指向）在运行时确定，随时可能改变；作用域在定义时确定，并且不会改变。

::: tip
1. 全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。 它会执行两件事:创建一个全局的 `window` 对象(浏览器的情况下)，并且设置 `this` 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
2. 函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序(将在后文讨论)执行一系列步骤。
3. `Eval`函数执行上下文 — 执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval ，
:::

> 每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。**某个执行环境中所有代码执行完后就会销毁环境，保存其中的所有变量和函数定义也随之销毁。**

> web浏览器全局执行环境就是`window`对象，`node`环境就是`global`
:::

## 垃圾回收(GC)机制
> 找出那些不再继续使用的变量，然后释放其内存。垃圾收集器会固定时间间隔，进行这一周期操作。

+ 标记清除（Mark-Sweep)：变量进入环境就进行标记
> 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量。最后垃圾收集器完成内存清除工作，销毁带标记的值并回收所占用的内存空间。

![img](/dovis-blog/js/GC.png)

> 根可以理解为全局作用域，GC从全局作用域的变量，沿作用域逐层往里遍历（深度遍历），当遍历到堆中对象时，说明对象被引用，则打上一个标记，继续递归遍历（存在堆中对象引用另一个堆中对象），直到遍历到最后一个（最深一层的作用域）节点。

> 清除阶段，这次是遍历整个堆，回收没有打上标记的对象（非活动对象），连接到空闲链表上。

+ 引用计数
> IE9之前容易造成内存泄漏是因为循环引用的问题。这种垃圾回收机制是根据引用次数为0即清除掉的。

> 因为IE9之前的BOM和DOM对象是采用引用计数策略的回收机制。Js引擎采用标记清除策略。
```js
var element = document.getElementById('some——element');
var myObject = new Object()
myObject.element = element;
element.someObject = myObject;
```
**所以myObject和element循环引用，引用次数都为2次，所以永远都不会被回收，就会造成内存泄漏**
这个时候就要手动断开DOM和JS对象的连接。`myObject.element = null; element.someObject = null;`

::: tip
引用计数策略的优缺点：
**优点**
+ 可立刻回收垃圾，当被引用值为0时。对象马上会把自己作为空闲空间连到空闲链表上，也就是说，在变成垃圾的时候就立刻回收了。
+ 因为是立刻回收，那么程序不会暂停很长一段时间去GC，那么最大暂停时间很短。
+ 不用去遍历堆里面的所有活动对象和非活动对象。

**缺点**
+ 计数器需要很大的位置，因为不能预估被引用的上限。
+ 最大的劣势是无法解决循环引用无法回收的问题。
:::

> 引用计数的次数计算策略：声明一个变量并将一个引用类型的值赋值给 这个变量，这个引用类型的值的引用次数就是1。同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1；当引用次数为0，则说明没办法访问这个值了。当垃圾收集器下一次运行时，就会释放引用次数为0的值所占的内存。

### 内存泄漏的情况
- 变量：
    + 意外的全局变量(使用严格模式避免)
    + 闭包引起（将事件处理函数定义在外部，解除闭包。）
- DOM:
    + 没有清理DOM的引用（手动删除）
    ```js
    var element = document.getElementById('element')
    element.mark = 'marked'
    // 移除element节点
    function remove() {
        element.parentNode.removeChild(element)
    }
    ```
    > 上面到例子中我们只是把节点移除了，但是变量`element`还在，该节点依然占据内存，所以应该手动添加`element=null`

    > 如果代码有`addEventListener`，由于事件处理句柄还在，所以别忘了`removeEventListener`移除事件，防止内存泄漏。
    + 被遗忘的定时器或者回调（定时器中有DOM的引用，手动删除定时器和DOM）
    ```js
    function foo() {
        var name  = 'xing'
        window.setInterval(function() {
            console.log(name)
        }, 1000)
    }
    foo()
    ```
    > 这段代码由于 window.setInterval 的存在，导致 name 内存空间始终无法被释放，如果不是业务要求的话，一定要记得在合适的时机使用clearInterval 进行清理。
    + 子元素存在引用引起内存泄漏

### 管理内存
一旦数据不再有用，最好通过将其设置为null来释放其引用--这个方式叫做解除引用。**这一做法适用全局变量和全局对象及其属性，因为局部的离开执行环境就会自动销毁**，不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

> 解除引用有助于消除循环引用的现像，而且也有助于垃圾回收。为了确保有效地回收内存，应该及时解除不使用的全局对象，全局对象的属性，全局变量，以及循环引用变量的引用。

### 垃圾回收算法
**评价垃圾回收算法性能几个方面：**
+ 吞吐量
+ 最大暂停时间
+ 堆使用效率
+ 访问的局部性

### 减少JavaScript的垃圾回收
1. 对象Object优化
> 为了最大限度的实现对象的重用，应该避免使用new语句，{}对象字面量的形式新建对象，因为意味着进行一次内存分配。**最好是每次函数调用完成之后，将需要返回的数据放入一个全局对象中，并返回这个全局对象。如果使用这种方式，就意味着每次调用都会导致全局对象内容的修改，可能会导致错误发生。**有一种方式可以重复利用对象：遍历某个对象的所有属性，并逐个删除，最终将对象清理为一个空对象。虽然这样比直接创建一个新对象耗时，但是将有效减少垃圾堆积，并且最终避免垃圾回收暂停。

2. 数组优化
> 将一个空数组[]赋值给一个数组对象，是清空数组的捷径，但是需要注意的是这样就会创建一个新的空对象，并且原来的数组对象变成了一片内存垃圾。实际上，将数组长度赋值为0也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。

3. 函数优化
> 只要是动态创建方法的地方，就有可能产生内存垃圾。

## 作用域链 (scope chain)
> 当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链用途是保证对执行环境有权访问的所有变量和函数有序访问。全局执行环境的变量对象始终都是作用域链中的最后一个对象。必须通过搜索来确定该标识符实际代表什么。如果在局部环境中找到了标识符，搜索停止，变量就绪。反之则沿着作用域链向上搜索。搜索过程将一直追朔到全局环境的变量对象。如果在全局环境中都没有找到这个标识符，则意味着该标识符（变量）未定义。**这样由多个执行环境的变量对象构成的链表就叫做作用域链**

::: tip
每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链。作用域链的前端始终都是当前执行代码所在环境的变量对象。如果这个环境是函数，就将其活动对象作为变量对象。
:::
## 闭包（closure）
> 闭包是指有权访问另一个函数作用域中的变量的内部函数。--《高级js程序设计》

> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。--《你不知道的js》

**换一句话说就是当一个变量既不是该函数内部当局部变量，也不是该函数当参数，相对于作用域来说，就是一个自由变量，这样就会形成一个闭包**

**例子1**
```js
let count=500 //全局作用域
function foo1() {
  let count = 0;//函数全局作用域
  function foo2() {
    count++;//函数内部作用域
    console.log(count);
    return count;
  }
  return foo2;//返回函数
}
let result = foo1();
result();//结果为1 这里没有什么问题
result();//结果为2  这里为2是因为此处闭包了，count=1没有被销毁，还保持着状态
```
**例子2**
```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    debugger;
    console.log(i); // 输出什么? 6 6 6 6
  }, 1000);
}
```
> setTimeout里面的回调函数是异步，而for循环是同步，异步必须等待一秒才能执行，这时i早就循环结束了。
- 解决方法：
    + 将for循环中的var改为let
    > for循环头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。
    + 把setTimeout套上一个函数
    ```js
    for (var i = 1; i <= 5; i++) {
    log(i); // 1 2 3 4 5
    }
    function log(i) {
    setTimeout(function timer() {
        debugger;
        console.log(i);
    }, 1000);
    }
    ``` 
    + 包装成匿名函数
    ```js
    for (var i = 1; i <= 5; i++) {
        (function (i) {
            setTimeout(function timer() {
            debugger;
            console.log(i);
            }, 1000);
        })(i) // 立即执行函数
    }
    ```
### 闭包注意事项
1. 函数作用域内的变量将在函数退出调用栈后清除，并且如果函数外部没有其他指向它们的引用，则将清理它们。但闭包将保留引用的变量并保持活动状态。

### 闭包应用场景
1. 保护作用
> 团队开发时，每个人的代码都放在一个私有的作用域中，防止变量名冲突；把需要的方法提供给别人，通过`return`或者`window.xxx`的方式暴露在全局下。

2. 保存作用
