# JS的作用域，作用域链，闭包

## 变量
> 复制保存着对象的某个变量时，操作的是对象的引用。为对象添加属性时，操作的是该对象本身。

> 1. 如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配到位置上。
> 2. 从一个变量向另一个变量复制引用类型到值，同样也会将存储在变量对象中值复制一份放到新变量 分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个小对象。

1. 如果初始化变量没有使用`var`声明，该变量会自动被添加到全局环境。
2. 基本数据类型的内存占据固定大小的空间，因此被保存在栈内存中。

## 作用域（scope）
> 所有变量都存在一个执行环境中，也称为作用域。

1. 词法作用域
> 简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你写代码时将变量和作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。

2. 动态作用域
> 在JS里，动态作用域和this机制息息相关。
```js
var a = 1;
function foo() {
    var a = 2;
    console.log(this.a) // 1  这个this指向全局对象Window
}
foo()
```
从上面的例子中可以看出结果不是取之于写代码的位置，而是取决于函数执行的位置。

::: tip
+ 词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。
+ 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。
:::

3. 块作用域
+ `try...catch`语句中catch语句会创建一个块作用域，catch的参数变量仅在catch内部有效。
+ 利用ES6的let，const关键字定义变量也会隐式创建块作用域。
## 垃圾回收(GC)机制
> 找出那些不再继续使用的变量，然后释放其内存。垃圾收集器会固定时间间隔，进行这一周期操作。

+ 标记清除：变量进入环境就进行标记
> 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量。最后垃圾收集器完成内存清除工作，销毁带标记的值并回收所占用的内存空间。

![img](/dovis-blog/js/GC.png)

> 根可以理解为全局作用域，GC从全局作用域的变量，沿作用域逐层往里遍历（深度遍历），当遍历到堆中对象时，说明对象被引用，则打上一个标记，继续递归遍历（存在堆中对象引用另一个堆中对象），直到遍历到最后一个（最深一层的作用域）节点。

> 清除阶段，这次是遍历整个堆，回收没有打上标记的对象。

+ 引用计数
> IE9之前容易造成内存泄漏是因为循环引用的问题。这种垃圾回收机制是根据引用次数为0即清除掉的。

> 因为IE9之前的BOM和DOM对象是采用引用计数策略的回收机制。Js引擎采用标记清除策略。
```js
var element = document.getElementById('some——element');
var myObject = new Object()
myObject.element = element;
element.someObject = myObject;
```
**所以myObject和element循环引用，引用次数都为2次，所以永远都不会被回收，就会造成内存泄漏**
这个时候就要手动断开DOM和JS对象的连接。`myObject.element = null; element.someObject = null;`

::: tip
引用计数策略的优缺点：
**优点**
+ 可立刻回收垃圾，当被引用值为0时。对象马上会把自己作为空闲空间连到空闲链表上，也就是说，在变成垃圾的时候就立刻回收了。
+ 因为是立刻回收，那么程序不会暂停很长一段时间去GC，那么最大暂停时间很短。
+ 不用去遍历堆里面的所有活动对象和非活动对象。

**缺点**
+ 计数器需要很大的位置，因为不能预估被引用的上限。
+ 最大的劣势是无法解决循环引用无法回收的问题。
:::

> 引用计数的次数计算策略：声明一个变量并将一个引用类型的值赋值给 这个变量，这个引用类型的值的引用次数就是1。同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1；当引用次数为0，则说明没办法访问这个值了。当垃圾收集器下一次运行时，就会释放引用次数为0的值所占的内存。

### 内存泄漏的情况
- 变量：
    + 意外的全局变量(使用严格模式避免)
    + 闭包引起（将事件处理函数定义在外部，解除闭包。）
- DOM:
    + 没有清理DOM的引用（手动删除）
    + 被遗忘的定时器或者回调（定时器中有DOM的引用，手动删除定时器和DOM）
    + 子元素存在引用引起内存泄漏
    
### 管理内存
一旦数据不再有用，最好通过将其设置为null来释放其引用--这个方式叫做解除引用。**这一做法适用全局变量和全局对象及其属性，因为局部的离开执行环境就会自动销毁**，不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

> 解除引用有助于消除循环引用的现像，而且也有助于垃圾回收。为了确保有效地回收内存，应该及时解除不使用的全局对象，全局对象的属性，全局变量，以及循环引用变量的引用。

## 作用域链 (scope chain)
> 当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链用途是保证对执行环境有权访问的所有变量和函数有序访问。全局执行环境的变量对象始终都是作用域链中的最后一个对象。

::: tip
每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链。
:::
## 闭包（closure）