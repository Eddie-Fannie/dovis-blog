# JS的作用域，作用域链，闭包

## 变量
> 复制保存着对象的某个变量时，操作的是对象的引用。为对象添加属性时，操作的是该对象本身。

> 1. 如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配到位置上。
> 2. 从一个变量向另一个变量复制引用类型到值，同样也会将存储在变量对象中值复制一份放到新变量 分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个小对象。

1. 如果初始化变量没有使用`var`声明，该变量会自动被添加到全局环境。
2. 基本数据类型的内存占据固定大小的空间，因此被保存在栈内存中。

## 作用域（scope）
> 所有变量都存在一个执行环境中，也称为作用域。

## 垃圾回收(GC)机制
> 找出那些不再继续使用的变量，然后释放其内存。垃圾收集器会固定时间间隔，进行这一周期操作。

+ 标记清除：变量进入环境就进行标记
> 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量。最后垃圾收集器完成内存清除工作，销售带标记的值并回收所占用的内存空间。

+ 引用计数
> IE9之前容易造成内存泄漏是因为循环引用的问题。这种垃圾回收机制是根据引用次数为0即清除掉的。

> 因为IE9之前的BOM和DOM对象是采用引用计数策略的回收机制。Js引擎采用标记清除策略。
```js
var element = document.getElementById('some——element');
var myObject = new Object()
myObject.element = element;
element.someObject = myObject;
```
**所以myObject和element循环引用，引用次数都为2次，所以永远都不会被回收，就会造成内存泄漏**
这个时候就要手动断开DOM和JS对象的连接。`myObject.element = null; element.someObject = null;`

### 管理内存
一旦数据不再有用，最好通过将其设置为null来释放其引用--这个方式叫做解除引用。**这一做法适用全局变量和全局对象及其属性，因为局部的离开执行环境就会自动销毁**，不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

> 解除引用有助于消除循环引用的现像，而且也有助于垃圾回收。为了确保有效地回收内存，应该及时解除不使用的全局对象，全局对象的属性，全局变量，以及循环引用变量的引用。

## 作用域链 (scope chain)
> 当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链用途是保证对执行环境有权访问的所有变量和函数有序访问。全局执行环境的变量对象始终都是作用域链中的最后一个对象。

::: tip
每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链。
:::
## 闭包（closure）