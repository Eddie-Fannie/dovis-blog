# 用异步思想手写代码实现某些场景
## 实现一个`sleep`函数
> 每隔一秒输出`1,2,3,4,5`

```js
// Promise
function sleep(interval) {
    return new Promise(resolve => {
        setTimeout(resolve,interval)
    })
}
sleep(1000).then(() => {
    console.log(1)
})

async function one2fiveInAsync() {
    for(let i=1;i<=5;i++) {
        console.log(i)
        await sleep(1000)
    }
}
one2fiveInAsync()

// Generator
function *sleep(time) {
    yield new Promise((resolve,reject) {
        setTimeout(resolve,time)
    })
}
sleepGenerator(1000).next().value.then(()=>{console.log(1)})

// ES5
function sleep(callback,time) {
    if(typeof callback === 'function') {
        setTimeout(callback,time)
    }
}
```

## 用Promise实现Ajax例子
```js
var getJson = function(url) {
    var promise = new Promise((resolve, reject) => {
        var client = new XMLHttpRequest;
        client.open('GET', url)
        client.onreadystatechange = handler;
        client.responseType = 'json'
        client.setRequestHeader('Accept', 'application/json')
        client.send()
    })
    function handler() {
        if(this.readState !== 4) {
            return;
        }
        if(this.status === 200) {
            console.log(this.response)
            resolve(this.response)
        } else {
            reject(new Error(this.statusText))
        }
    }
    return promise
}

getJson('http://ueclub.kingdee.com/kux/index/top').then((json) => {
    console.log(json)
}, (error) => {
    console.log(error)
})
```

## 实现红绿灯任务控制
> 红灯`3s`亮一次,绿灯`1s`亮一次，黄灯`2s`亮一次。如何让3个灯不断交替重复地亮呢？

```js
function red() {
    console.log('红灯亮')
} 

function yellow() {
    console.log('黄灯亮')
}
function green() {
    console.log('绿灯亮')
}

const task = (timer,light) => {
    return new Promise((resolve,reject) => {
        setTimeout(() => {
            if(light === 'red') {
                red()
            } else if(light === 'green') {
                green()
            }  else if(light === 'yellow') {
                yellow()
            }
            resolve()
        },timer)
    })
}

const stepLight = () => {
    task(3000,'red')
        .then(() => task(1000,'green'))
        .then(() => task(2000,'yellow'))
        .then(stepLight) // 递归实现红绿灯重复执行
}
stepLight()

// async...await
const stepLight = async () => {
    await task(3000,'red')
    await task(1000, 'green')
    await task(2000, 'yellow')
    stepLight()
}
stepLight()
```

## 请求图片进行预先加载
先实现一个请求图片的方法
```js
const loadImg = urlId => {
    const url = `https://www.image.com/${urlId}`
    return new Promise((resolve,reject) => {
        const img = new Image()
        img.onerror = function() {
            reject(urlId)
        }
        img.onload = function() {
            resolve(urlId)
        }
        img.src = url
    })
}
```

根据图片`urlId`依次请求图片，代码

```js
const urlIds = [1,2,3,4,5] 
urlIds.reduce((prevPromise,urlId) => {
    return prevPromise.then(() => loadImg(urlId))
},Promise.resolve())
```

面向过程
```js
const loadImgOneByOne = index => {
    const length = urlIds.length
    loadImg(urlIds[index]).then(() => {
        if(index === length -1) {
            return
        } else {
            loadImgOneByOne(++index)
        }
    })
}
loadImgOneByOne(0)
```

`async...await`
```js
const loadImgOneByOne = async () => {
    for(let i of urlIds) {
        await loadImg(urlIds[i])
    }
}
loadImgOneByOne()
```

- 想要提升效率将所有图片的请求一次性发出
```js
const urlIds = [1,2,3,4,5]
const promiseArray = urlIds.map(urlId => loadImg(urlId))
Promise.all(promiseArray)
    .then(() => {
        console.log('finish load all')
    })
    .catch(() => {
        console.log('promise all catch')
    })
```

- 控制最大并发数为`3`，最多一起发`3`个请求，剩下`2`个一起发出
```js
const loadByLimit = (urlIds,loadImg,limit) => {
    const urlIdsCopy = [...urlIds]
    if(urlIdsCopy.length <= limit) {
        //如果数组长度小于最小并发数，则直接发出请求
        const promiseArray = urlIds.map(urlId => loadImg(urlId))
        return Promise.all(promiseArray)
    }
    
    const promiseArray = urlIdsCopy.splice(0,limit).map(urlId => loadImg(urlId))

    urlIdsCopy.reduce(
        (prevPromise,urlId) =>
        prevPromise
            .then(() => Promise.race(promiseArray))
            .catch(error => {console.log(error)})
            .then(resolvedId => {
                // 将resolvedId从promiseArray中删除
                let resolvedIdPostion = promiseArray.findIndex(id => resolvedId === id)
                promiseArray.splice(resolvedIdPostion,1)
                promiseArray.push(loadImg(urlId))
            })
        ,
        Promise.resolve()
    )
    .then(() => Promise.all(promiseArray))
}
```