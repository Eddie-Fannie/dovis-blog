# 前端如何优化网站性能
1. 减少`HTTP`请求数量
- 使用`CSS`雪碧图，减少图片总字节数
- 合并`CSS`和`JS`文件
- 采用[懒加载](/dovis-blog/advanced/Performance/vue实现一个图片懒加载指令.html)

2. 利用浏览器缓存
3. 减少重排
> 重排是`DOM`的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 `DOM` 树上的所有其它结点的`visibility`属性，这也是重排低效的原因。如果重排的过于频繁，`CPU`使用率就会急剧上升。减少重排，如果需要在`DOM`操作时添加样式，尽量使用增加`class`属性，而不是通过`style`操作样式。
4. 减少`Dom`操作
5. 图标使用`IconFont`替换
6. 避免`head`标签`JS`堵塞
> 所有放在`head`标签里的`css`和`js`都会堵塞渲染。如果这些`CSS`和`JS`需要加载和解析很久的话，那么页面就空白了。

7. 减少`head`标签里的`CSS`资源
> 由于`CSS`必须要放在`head`标签里面，如果放在`body`里面，一旦加载好之后，又会对`layout`好的`dom`进行重排，样式可能又会发生闪烁。但是一旦放在`head`标签里面又会堵塞页面渲染，若要加载很久，页面就会保持空白状态。所以要尽可能地减少`CSS`的代码量。

::: tip
有两种解决办法，第一种是把`script`放到`body`后面，这也是很多网站采取的方法。第二种是给`script`加`defer`的属性，`defer`是`html5`新增的属性。一旦`script`是`defer`延迟的，那么这个`script`将会异步加载，但不会马上执行，会在`readystatechange`变为`Interactive`后按顺序依次执行
:::
8. 不要放太多`base64`在`CSS`里面
>放太多`base64`放在`CSS`里面，会导致`CSS`极速膨胀，把一张`3k`的图片转成`base64`，体积将会变成`4k`

## vue项目中的性能优化
1. `v-if/v-show`
> `v-if` 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。`v-show` 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 `CSS` 的 `display` 属性进行切换。所以，`v-if` 适用于在运行时很少改变条件，不需要频繁切换条件的场景；`v-show` 则适用于需要非常频繁切换条件的场景。

2. `v-for`避免使用`v-if`
> `v-for` 比 `v-if` 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 `computed` 属性。

3. 长列表性能优化
> `Vue` 会通过 `Object.defineProperty` 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 `Vue` 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 `Vue` 劫持我们的数据呢？可以通过 `Object.freeze` 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。

4. 事件的销毁
> `Vue` 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果在 `js` 内使用 `addEventListener` 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露
```js
beforeDestroy() {
    removeEventListener('click', this.click, false)
}
```
5. 图片懒加载
> 对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 `Vue` 的 `vue-lazyload` 插件

6. 路由懒加载
> `Vue` 是单页面应用，可能会有很多的路由引入 ，这样使用 `webpcak` 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。

7. 第三方插件按需引入
`babel-plugin-component`

8. 提取公共代码
如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：
- 相同的资源被重复加载，浪费用户的流量和服务器的成本。
- 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。
所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。`Webpack` 内置了专门用于提取多个`Chunk` 中的公共部分的插件 `CommonsChunkPlugin`

9. 去除多余`css`--库`purgecss`
10. 动态组件记得使用`keep-alive`
