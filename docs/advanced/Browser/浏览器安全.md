# 浏览器安全
## XSS
跨站脚本（`Cross Site Scripting`）
::: tip
`XSS`（跨站脚本攻击）是指攻击者在返回的`HTML`中嵌入`javascript`脚本，为了减轻这些攻击，需要在`HTTP`头部配上，`set-cookie`：
- `httponly-`这个属性可以防止`XSS`,它会禁止`javascript`脚本来访问`cookie`。
- `secure -` 这个属性告诉浏览器仅在请求为`https`的时候发送`cookie`。
:::

### 持久型
> 持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。

### 非持久型
> 非持久型相比于前者危害就小的多了，一般通过修改 `URL` 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。

## 防御XSS
1. 转义字符
> 首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义。多的文本可以利用`js-xss`

2. `CSP`
> `CSP` 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。
+ 开启`CSP`
    - 设置 `HTTP Header` 中的 `Content-Security-Policy`
    ```bash
    # 只允许加载本站资源：
    Content-Security-Policy: default-src ‘self’

    # 只允许加载HTTPS协议图片
    Content-Security-Policy: img-src https://*

    # 允许加载任何来源框架
    Content-Security-Policy: child-src 'none'
    ```
    - 设置 `meta` 标签的方式 `<meta http-equiv="Content-Security-Policy">`

## CSRF
> `CSRF` 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。

+ 防御CSRF
    - `Get` 请求不对数据进行修改
    - 不让第三方网站访问到用户 `Cookie`
    - 阻止第三方网站请求接口
    - 请求时附带验证信息，比如验证码或者 `Token`
    > 服务器下发一个随机 `Token`，每次发起请求时将 `Token` 携带上，服务器验证 `Token` 是否有效。

## 点击劫持
> 点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 `iframe` 嵌套的方式嵌入自己的网页中，并将 `iframe` 设置为透明，在页面中透出一个按钮诱导用户点击。

+ 防御：
    - `X-FRAME-OPTIONS`
    > `X-FRAME-OPTIONS` 是一个 `HTTP` 响应头，在现代浏览器有一个很好的支持。这个 `HTTP` 响应头 就是为了防御用 `iframe` 嵌套的点击劫持攻击。
    > 1. `DENY`：表示页面不允许通过`iframe`的方式展示
    > 2. `SAMEORIGIN`：表示页面可以在相同域名下通过`iframe`方式展示
    > 3. `ALLOW-FROM`：表示页面可以在指定来源的`iframe`中展示

    - js防御
    > 当通过 `iframe` 的方式加载页面时，攻击者的网页直接不显示所有内容了。

## 中间人攻击
> 中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。

当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。`HTTPS` 就可以用来防御中间人攻击，但是并不是说使用了 `HTTPS` 就可以高枕无忧了，因为如果你没有完全关闭 `HTTP` 访问的话，攻击方可以通过某些方式将 `HTTPS` 降级为 `HTTP` 从而实现中间人攻击。

![img](/dovis-blog/other/29.jpg)

::: tip
+ 过程原理：
    - 本地请求被劫持（如`DNS`劫持等），所有请求均发送到中间人的服务器
    - 中间人服务器返回中间人自己的证书
    - 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输
    - 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密
    - 中间人以客户端的请求内容再向正规网站发起请求
    - 因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据
    - 中间人凭借与正规网站建立的对称加密算法对内容进行解密
    - 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输
    - 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密

> 由于缺少对证书的验证，所以客户端虽然发起的是 `HTTPS` 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。
:::