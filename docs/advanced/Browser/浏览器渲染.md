# 浏览器渲染机制
## 进程/线程
> 进程（`process`）是程序的一次执行过程，程序在执行过程种分配和管理资源的基本单位。

> 线程（`thread`）是`CPU`调度和分配的基本单位，可以和同一个进程的其他线程共享进程所拥有的全部资源

::: tip
浏览器地址输入一个`URL`，浏览器根据`DNS`服务器得到域名的`IP`地址，这个时候浏览器进程会向这个`IP`地址发送请求，获取`HTML`内容。然后将这些内容交给渲染进程。渲染进程解析内容，解析遇到的请求网络的资源又返回来交给浏览器进程进行加载，同时通知主进程（浏览器进程），需要插件进程加载插件资源，执行插件代码。解析完成后，渲染进程得到图像帧，并交给`GPU`进程，将其转化为图像显示屏幕。[四种进程介绍](/basis/JavaScript/Event-Loop.html#浏览器包含了哪些进程)
:::

> 首先，当我们是要浏览一个网页，我们会在浏览器的地址栏里输入`URL`，这个时候`Browser Process`会向这个`URL`发送请求，获取这个`URL`的`HTML`内容，然后将`HTML`交给`Renderer Process`，`Renderer Process`解析`HTML`内容，解析遇到需要请求网络的资源又返回来交给`Browser Process`进行加载，同时通知`Browser Process`，需要`Plugin Process`加载插件资源，执行插件代码。解析完成后，`Renderer Process`计算得到图像帧，并将这些图像帧交给`GPU Process`，`GPU Process`将其转化为图像显示屏幕。

### 浏览器进程模式
::: tip
Chrome浏览器多进程的好处：
1. 更高的容错性。当今`WEB`应用中，`HTML，JavaScript`和`CSS`日益复杂，这些跑在渲染引擎的代码，频繁的出现BUG，而有些`BUG`会直接导致渲染引擎崩溃，多进程架构使得每一个渲染引擎运行在各自的进程中，相互之间不受影响，也就是说，当其中一个页面崩溃挂掉之后，其他页面还可以正常的运行不收影响。
2. 更高的安全性和沙盒性（`sanboxing`）。渲染引擎会经常性的在网络上遇到不可信、甚至是恶意的代码，它们会利用这些漏洞在你的电脑上安装恶意的软件，针对这一问题，浏览器对不同进程限制了不同的权限，并为其提供沙盒运行环境，使其更安全更可靠。
3. 更高的响应速度。在单进程的架构中，各个任务相互竞争抢夺`CPU`资源，使得浏览器响应速度变慢，而多进程架构正好规避了这一缺点。
:::

> 为了节省内存，Chrome提供了四种进程模式（`Process Models`），不同的进程模式会对 `tab` 进程做不同的处理。

- `Process-per-site-instance (default) ` - 同一个 `site-instance` 使用一个进程
> 当你打开一个 `tab` 访问 `a.baidu.com` ，然后再打开一个 `tab` 访问 `b.baidu.com`，这两个 `tab` 会使用两个进程。而如果你在 `a.baidu.com` 中，通过JS代码打开了 `b.baidu.com` 页面，这两个 tab 会使用同一个进程。
- `Process-per-site`：同一个`site`一个进程
- `Process-per-tab`：每个`tab`使用一个进程
- `single Process`：所有`tab`共用一个进程

::: tip
- `site` 指的是相同的 `registered domain name`(如：`google.com` ，`bbc.co.uk`)和`scheme` (如：`https://`)。比如`a.baidu.com`和`b.baidu.com`就可以理解为同一个 `site`（注意这里要和 `Same-origin policy` 区分开来，同源策略还涉及到子域名和端口）。
- `site-instance` 指的是一组 `connected pages from the same site`，这里 `connected` 的定义是 `can obtain references to each other in script code` 怎么理解这段话呢。满足下面两情况并且打开的新页面和旧页面属于上面定义的同一个 `site`，就属于同一个 `site-instance`
    + 用户通过`<a target="_blank">`这种方式点击打开的新页面
    + `JS`代码打开的新页面（比如 `window.open`)
:::

## 解析文档
上述有提到渲染进程会解析内容，然后遇到请求网络的资源就会返回给浏览器进程进行加载，那么解析这个过程又是如何进行的呢？

### 构建`DOM`树
渲染进程的主线程开始工作，解析`HTML`文本并转为`DOM`树

### 子资源加载
当主线程解析遇到一些需要额外加载的资源时，如图片，`CSS`和`JavaScript`，为了提高请求速度，会向浏览器进程的网络线程发起请求。

### JS阻塞解析过程
当`HTML`解析器遇到`script`标签时，会暂停`HTML`解析工作，转而去加载`Js`代码。因为这部分代码可能会影响文档结构。也会导致`CSSOM`也阻塞。

### 样式计算
主线程解析计算完`CSS`产生`CSS`规则书，才会对文档节点赋予最终的样式。

> 处理过程：1.把`CSS`转换成浏览器能够理解的结构--`StyleSheets`，该结构同时具备了查询和修改功能。2.转换样式表中的属性值，使其标准化。3.计算出`DoM`树中的每个节点具体样式

### 布局（初次回流）
>主线程遍历`DOM`并计算样式，创建一个具体横纵坐标以及盒子边界大小数据的布局树（`layout tree`）。布局树可能与`DOM`树相似，但它只包含和页面即将呈现的节点相关的信息。如果某个元素设置了`display: none`，虽然它会呈现在`DOM`树中但并不会包含于布局树当中；如果有一个伪类元素`p::before{ content: 'Hi!' }`， 那么它虽然不在`DOM`树中，但仍然会出现在布局树当中。

### 分层
渲染引擎为特定的节点生成专用的图层，并生成一棵对应的图层树。拥有层叠上下文的元素会被单独提升为一层；需要剪裁的地方会被创建为图层（当超出容器内容被隐藏或出现滚动条均会被提升为单独层）

### 图层绘制
渲染引擎对图层树每个图层进行绘制。渲染引擎会把一个图层的绘制分成很多小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表。当图层的绘制列表准备好之后，主线程会把绘制列表交给合成线程。

### 栅格化操作
> 将图块转换为位图，而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在里面执行的。

### 合成和显示
一旦所有图块都栅格化，合成线程会生成一个绘制图块的命令，然后将该命令提交给浏览器进程。浏览器进程的`viz`组件接收合成线程发过来的命令。然后根据命令将其内容绘制到内存中，最后再将内存显示在屏幕上

## 性能优化策略
> 基于上面介绍的浏览器渲染原理，`DOM` 和 `CSSOM` 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。

- `JS`优化： `<script>` 标签加上 `defer`属性 和 `async`属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。`defer`属性：用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。`async`属性：`HTML5`新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。
- `CSS`优化：`<link>` 标签的 `rel`属性 中的属性值设置为 `preload` 能够让你在你的`HTML`页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能。

## 渲染过程总结
1. 浏览器解析`HTML`，`CSS`和`JavaScript`脚本。等脚本加载后，通过 `DOM API` 和 `CSSOM API` 来操作 `DOM Tree` 和 `CSS Rule Tree`。
2. 解析完成后，浏览器引擎通过两种树结构来构造渲染树。**渲染树只包含可见节点**

::: tip
- 构建渲染树的过程，浏览器还做了一些关键的小动作：
    + 从`DOM`树的根节点开始遍历，筛选出所有可见的节点；
    + 仅针对可见节点，为其匹配`CSSOM`中的`CSS`规则；
    + 发射可见节点，连同其内容和计算样式。
:::

3. `Layout`回流：根据生成的渲染树，进行回流，得到节点的几何信息。
4. 重绘：根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. 将像素发给`GPU`进程，展示在页面上。

## 回流(`Reflow`)
> 回流是布局或者几何属性需要改变就称为回流。**回流一定会导致重绘**

+ 什么情况会回流（为了求一个即时性和准确性）
    - 添加或者删除可见的`DOM`元素
    - 元素的位置发生变化
    - 元素的尺寸发生变化
    - 内容发生变化
    - **页面一开始的时候**
    - 浏览器的窗口尺寸变化
    - 设置`style`属性的值
    - 计算`offsetWidth/offsetHeight/clientWidth/等`的属性
    - 调用`getComputedStyle/currentStyle`
## 重绘(`Repaint`)
> 重绘是当前节点需要更改外观而不会影响布局。**重绘不一定会引起回流**

::: tip
+ 并且很多人不知道的是，重绘和回流其实也和 `Eventloop` 有关。
    - 当 `Eventloop` 执行完 `Microtasks` 后，会判断 `document` 是否需要更新，因为浏览器是 `60Hz` 的刷新率，每 `16.6ms` 才会更新一次。
    - 然后判断是否有 `resize` 或者 `scroll` 事件，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 `16ms` 才会触发一次，并且自带节流功能。
    - 判断是否触发了 `media query`
    - 更新动画并且发送事件
    - 判断是否有全屏操作事件
    - 执行 `requestAnimationFrame` 回调
    - 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
    - 更新界面
    - 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调。
:::

## 减少重绘与回流
- 合并多次对`DOM`和样式的修改，然后一次性处理掉
- 使用`transform`替代`top`（`css3`的硬件加速，不会引起重绘回流。还有`opacity`，`filters`,`Will-change`这些属性）
- 使用`visibility`替换`display: none`，前者只会引起重绘，后者会引起回流（布局改变了）
- 不要把节点的属性值放在一个循环里当成循环的变量
- 不要使用`table`布局
- 动画速度越快，回流次数越多，可以使用`reuqestAnimationFrame`
- `CSS`避免节点层级过多
- 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点
    + 使用`will-change`生成新图层
    + `video/iframe`标签
- 对DOM一系列修改时，我们可以使元素脱离文档流，对其进行多次修改，然后将元素带回到文档中。因为这个时候修改，元素已经不在渲染树中。

## 为什么操作DOM慢
> 因为 `DOM` 是属于渲染引擎中的东西，而 `JS` 又是 `JS` 引擎中的东西。当我们通过 `JS` 操作 `DOM` 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 `DOM` 次数一多，也就等同于一直在进行线程之间的通信，并且操作 `DOM` 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。