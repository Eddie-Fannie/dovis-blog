# 浏览器渲染机制
## 进程/线程
> 进程（`process`）是程序的一次执行过程，程序在执行过程种分配和管理资源的基本单位。

> 线程（`thread`）是`CPU`调度和分配的基本单位，可以和同一个进程的其他线程共享进程所拥有的全部资源

::: tip
浏览器地址输入一个`URL`，浏览器根据`DNS`服务器得到域名的`IP`地址，这个时候浏览器进程会向这个`IP`地址发送请求，获取`HTML`内容。然后将这些内容交给渲染进程。渲染进程解析内容，解析遇到的请求网络的资源又返回来交给浏览器进程进行加载，同时通知主进程（浏览器进程），需要插件进程加载插件资源，执行插件代码。解析完成后，渲染进程得到图像帧，并交给`GPU`进程，将其转化为图像显示屏幕。[四种进程介绍](/basis/JavaScript/Event-Loop.html#浏览器包含了哪些进程)
:::

## 解析文档
上述有提到渲染进程会解析内容，然后遇到请求网络的资源就会返回给浏览器进程进行加载，那么解析这个过程又是如何进行的呢？

### 构建`DOM`树
渲染进程的主线程开始工作，解析`HTML`文本并转为`DOM`树

### 子资源加载
当主线程解析遇到一些需要额外加载的资源时，如图片，`CSS`和`JavaScript`，为了提高请求速度，会向浏览器进程的网络线程发起请求。

### JS阻塞解析过程
当`HTML`解析器遇到`script`标签时，会暂停`HTML`解析工作，转而去加载`Js`代码。因为这部分代码可能会影响文档结构。也会导致`CSSOM`也阻塞。

### 样式计算
主线程解析计算完`CSS`产生`CSS`规则书，才会对文档节点赋予最终的样式。

### 布局（初次回流）
>主线程遍历`DOM`并计算样式，创建一个具体横纵坐标以及盒子边界大小数据的布局树（`layout tree`）。布局树可能与`DOM`树相似，但它只包含和页面即将呈现的节点相关的信息。如果某个元素设置了`display: none`，虽然它会呈现在`DOM`树中但并不会包含于布局树当中；如果有一个伪类元素`p::before{ content: 'Hi!' }`， 那么它虽然不在`DOM`树中，但仍然会出现在布局树当中。

## 性能优化策略
> 基于上面介绍的浏览器渲染原理，`DOM` 和 `CSSOM` 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。

- `JS`优化： `<script>` 标签加上 `defer`属性 和 `async`属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。`defer`属性：用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。`async`属性：`HTML5`新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。
- `CSS`优化：`<link>` 标签的 `rel`属性 中的属性值设置为 `preload` 能够让你在你的`HTML`页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能。

## 渲染过程总结
1. 浏览器解析`HTML`，`CSS`和`JavaScript`脚本。等脚本加载后，通过 `DOM API` 和 `CSSOM API` 来操作 `DOM Tree` 和 `CSS Rule Tree`。
2. 解析完成后，浏览器引擎通过两种树结构来构造渲染树。**渲染树只包含可见节点**
3. `Layout`回流：根据生成的渲染树，进行回流，得到节点的几何信息。
4. 重绘：根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. 将像素发给`GPU`进程，展示在页面上。

## 回流(`Reflow`)
> 回流是布局或者几何属性需要改变就称为回流。**回流一定会导致重绘**

+ 什么情况会回流
    - 添加或者删除可见的`DOM`元素
    - 元素的位置发生变化
    - 元素的尺寸发生变化
    - 内容发生变化
    - **页面一开始的时候**
    - 浏览器的窗口尺寸变化
    - 设置`style`属性的值
    - 计算`offsetWidth/offsetHeight`的属性
## 重绘(`Repaint`)
> 重绘是当前节点需要更改外观而不会影响布局。**重绘不一定会引起回流**

## 减少重绘与回流
- 合并多次对`DOM`和样式的修改，然后一次性处理掉
- 使用`transform`替代`top`（`css3`的硬件加速，不会引起重绘回流。还有`opacity`，`filters`,`Will-change`这些属性）
- 使用`visibility`替换`display: none`，前者只会引起重绘，后者会引起回流（布局改变了）
- 不要把节点的属性值放在一个循环里当成循环的变量
- 不要使用`table`布局
- 动画速度越快，回流次数越多，可以使用`reuqestAnimationFrame`
- `CSS`避免节点层级过多
- 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点
- 对DOM一系列修改时，我们可以使元素脱离文档流，对其进行多次修改，然后将元素带回到文档中。因为这个时候修改，元素已经不在渲染树中。