# 浏览器缓存
> 浏览器的缓存机制也就是我们说的`HTTp`缓存机制，对于一个数据请求，可以分为`网络请求`、`后端处理`、`浏览器响应`三个步骤

## 缓存过程分析
> 浏览器与服务器通信的方式为应答模式，即是：浏览器发起`HTTP`请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中`HTTP`头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中。

## 缓存位置
> 依次查找缓存都没有命中，才会去请求网络

- `Service Worker`
> 当`Service Worker`没有命中缓存的时候，我们需要去调用`fetch`函数获取数据。也就是说，如果我们没有在`Service Worker`命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 `Memory Cache`中还是从网络请求中获取的数据，浏览器都会显示我们是从`Service Worker`中获取的内容。

- `Memory Cache`
> 内存中的缓存，一旦关闭`tab`页面，内存中的缓存也被释放了。读取比硬盘的快。内存存储小文件。

- `Disk Cache`
> 硬盘缓存，读取慢，但是什么都可以存。比`Memory Cache`容量大。

+ `Push Cache`
    - 可以推送 `no-cache` 和 `no-store` 的资源
    - 前三个缓存没有命中时才会使用。会话结束时被释放。

## 缓存策略
### 强缓存
> 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。强缓存有3种情况：

- 不存在缓存结果和缓存标识，强制缓存失败，则直接向服务器发请求
- 存在缓存结果和缓存标识，但结果失效，强制缓存失效，则使用协商缓存
- 存在缓存结果和缓存标识，且该结果尚未失效，强制缓存失效，直接返回该结果。

> 强缓存缓存规则可以通过设置两种`HTTP Header`实现：`Expires`和`Cache-Control`强缓存表示在缓存期间不需要请求，状态码为200。

- `Expires`
```http
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```
> `Expires`受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

- `Cache-control`
```http
Cache-control: max-age=30
```
> 优先级高于`Expires`。该属性值表示资源会在30秒后过期，需要再次请求。可以在请求头或响应头中设置。并且可以组合多种指令。

| 指令 | 作用|
| -----|----- |
|`public`| 表示响应可以被客户端和代理服务器缓存 |
|`private`| 表示响应只可以被客户端缓存 |
|`max-age=30`| 缓存30s就要重新请求 |
|`s-maxage=30`| 覆盖`max-age`，作用一样，只在代理服务器中生效 |
|`no-store`| 不缓存任何响应 |
|`no-cache`| 资源被缓存，但是立即失效，下次会发起请求验证资源是否过期 |
|`max-stale = 30`| 30秒内，即使缓存过期，也使用该缓存 |
|`max-fresh`| 30秒内获取最新的响应 |

### 协商缓存
> 如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种`HTTP Header`实现：`Last-Modified`和`ETag`。**当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回`304`状态码，并且更新浏览器缓存有效期。**

- `Last-Modified`和`If-Modified-Since`
> `Last-Modified`表示本地文件最后修改日期，`If-Modified-Since`会将`Last-Modified`的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回`304`状态码。
::: warning
1. 如果本地打开缓存文件，即使没有对文件修改，但还是会造成该值修改，服务端不能命中缓存导致发送相同的资源
2. 因为该值只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中，不会返回正确的资源。
:::

- `ETag`和`If-None-Match`
> ETag 类似于文件指纹，`If-None-Match`会将当前`ETag`发送给服务器，询问该资源`ETag`是否变动，有变动的话就将新的资源发送回来。并且`ETag`优先级比`Last-Modified`高。

一张图简单的表明浏览器缓存的一个过程：
![img](/dovis-blog/other/1.png)

## 实际场景
1. **频繁变动的资源**
> 对于频繁变动的资源，首先需要使用`Cache-Control: no-cache`使浏览器每次都请求服务器，然后配合`ETag`或者`Last-Modified`来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

2. **代码文件**
> 一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年`Cache-Control: max-age=31536000`，这样只有当`HTML`文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。