# 浏览器跨域
> 协议，端口和主机不是相同的，则跨域。其实主要是用来防止 `CSRF` 攻击的。简单点说，`CSRF` 攻击是利用用户的登录态发起恶意请求。

## `JSONP`
> 能够直接访问响应文本，支持在浏览器与服务器之间双向通信。 

```js
function jsonp(url, jsonpCallback, success) {
  let script = document.createElement('script')
  script.src = url
  script.async = true
  script.type = 'text/javascript'
  window[jsonpCallback] = function(data) {
    success && success(data)
  }
  document.body.appendChild(script)
}
jsonp('http://xxx', 'callback', function(value) {
  console.log(value)
})
```

+ `JSONP`缺点
> 首先`JSONP`是从其他域中加载代码执行。如果其他域不安全，很有可能会在响应中夹带一些恶意代码，而此时除了完全放弃`JSONP`调用之外，没有办法追究。**要确定`JSONP`请求是否失败也不容易**

## `CORS`
服务端设置`Access-Control-Allow-Origin`就可以开启`CORS`。该属性表示哪些域名可以访问资源，如果设置通配符表示所有网站都可以访问资源。虽然设置`CORS `和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。

- **简单请求**
1. 方法 `get post head`
2. `Content-Type`仅限：`text/plain,multipart/form-data,application/x-www-form-urlencoded`
3. `HTTP`头信息不超过`Accept Accept-Language Content-Language Last-Evnet-ID Content-Type`

- **复杂请求**
> 对于复杂请求来说，首先会发起一个预检请求，该请求是`option`方法的，返回码为`204`。通过该请求来知道服务端是否允许跨域请求。

## `document.domain`
> 该方式只能用于二级域名相同的情况下，比如`a.test.com`和`b.test.com`。只需要给页面添加`document.domain = 'test.com'`表示二级域名相同就可以实现跨域。

## `devServer` vue项目
> 跨域是浏览器禁止的，服务端并不禁止跨域，所以浏览器可以发给自己的服务端然后由自己的服务端再转发给要跨域的服务端，做一层代理。`vue-cli`的`proxy`用的就是`http-proxy-middleware`中间件，`http-proxy-middleware`内部用`http-proxy`

## 两个浏览器窗口之间通信
1. `localStorage`
2. `WebSocket`
> 所有的`WebSocket`都监听同一个服务器地址，利用`send`发送消息，利用`onmessage`获取信息的变化，不仅能不同窗口，还能跨浏览器，兼容性最佳，只是需要消耗服务器资源。
3. `postMessage`
借助`iframe`或`window.open`

```js
otherWindow.postMessage(message, targetOrigin, [transfer]);
```
- `otherWindow`
> 其他窗口的一个引用，比如`iframe`的`contentWindow`属性、执行`window.open`返回的窗口对象、或者是命名过或数值索引的`window.frames`。

- `message`
> 将要发送到其他`window`的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。

- `targetOrigin`
> 通过窗口的`origin`属性来指定哪些窗口能接收到消息事件，其值可以是字符串""（表示无限制）或者一个`URI`。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配`targetOrigin`提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用`postMessage`传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的`origin`属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的`targetOrigin`，而不是不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。

- `transfer`可选
> 是一串和`message`同时传递的 `Transferable` 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。

## 即时通信技术
1. `Comet`
2. 服务器发送事件 `SSE`
3. `Web Sockets`