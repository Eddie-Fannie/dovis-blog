# `TCP`和`UDP`
**计算机网络体系结构**

![img](/dovis-blog/other/10.png)

## `TCP/IP`（传输控制协议/网际协议）
1. 应用层
2. 传输层
> 传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。

|  |  UDP  |  TCP |
|--|-------|------|
|是否连接 | 无连接 | 面向连接 |
|是否可靠|不可靠传输，不使用流量控制和拥塞控制|可靠传输，使用流量控制和拥塞控制|
|连接对象个数|支持一对一，一对多等多种方式通信|只能一对一|
|传输方式|面向报文|面向字节流|
|首部开销|小，仅8子节|首部最小20，最大60子节|
|场景|适用实时应用|适用可靠传输的应用，文件传输|

::: tip
+ `TCP`和`UDP`区别：
    - `TCP`提供可靠的服务。也就是说，通过`TCP`连接传送的数据，无差错，不丢失，不重复，且按序到达;`UDP`尽最大努力交付，即不保证可靠交付。并且因为`tcp`可靠，面向连接，不会丢失数据因此适合大数据量的交换。
    - `TCP`是面向字节流，`UDP`面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。
:::

## `TCP`特点
> `TCP`提供全双工通信。`TCP`允许通信双方的应用进程在任何时候都能发送数据。`TCP`连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给`TCP`的缓存后，就可以做自己的事，而`TCP`在合适的时候把数据发送出去。在接收时，`TCP`把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。

1. `TCP`连接的端点叫做套接字（`IP`地址:端口号)

## 可靠传输的工作原理
+ 理想传输条件特点：
    - 传输信道不产生差错
    - 不管发送方以多快速度发送数据，接收方总是来得及处理收到的数据。
> 实际的网络都不具备以上两个理想条件。但我们可以使用一些可靠传输协议，当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当降低发送数据的速度。这样一来，本来是不可靠的传输信道就能够实现可靠传输了。

## 停止等待协议
1. 可靠传输协议是这样设计的：发送方只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫做**超时重传**。要实现超时重传，就要在每发送完一个分组设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。

## TCP的三次握手和四次挥手
> 一个`TCP`连接由一个`4`元组构成，分别是两个`IP`地址和两个端口号（源端口和目的端口号，各占2个字节）。一个`TCP`连接通常分为三个阶段：**连接**、**数据传输**、**退出（关闭）**。**通过三次握手建立一个链接，通过四次挥手来关闭一个连接。** **当一个连接被建立或被终止时，交换的报文段只包含`TCP`头部，而没有数据。**

`TCP`报文头部结构
![img](/dovis-blog/other/11.png)

::: tip
`TCP`报文段首部的前`20`个字节是固定，后面有`4n`字节是根据需要而增加的选项(`n`是整数)。因此`TCP`首部的最小长度是`20`字节
:::

+ 重点字段
    - `seq`序号：占`32`位，用来标识`TCP`源向目的端发送的字节流，发送方发送数据时对此进行标记
    - 确认序号：`ack`序号，占`32`位，只有`ACK`标志位为`1`时，确认序号字段才有效，`ack=seq+1`。(**期望收到对方下一个报文段的第一个数据字节的序号**)
    - 标志位
        + `ACK(acknowledge)`：确认序号有效
        + `FIN(finish)`：释放一个连接
        + `PSH`：接收方应该尽快将这个报文交给应用层
        + `RST`：重置连接
        > 当`RST = 1`时，表明`TCP`连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。`RST`置`1`还用来拒绝一个非法的报文段或拒绝打开一个连接。`RST`也可称为重建位或重置位。
        + `SYN(synchronize)`：发起一个新连接
        + `URG`：紧急指针有效(`URG`=1时)

### 三次握手
> 确认通信双方收发数据的能力

三次握手过程

![img](/dovis-blog/other/12.png)

- **第一次握手：** 客户端向服务端发送请求，首先客户端随机生成一个起始序列号`ISN`（比如是`100`），那客户端向服务端发送的报文段包含`SYN`标志位（也就是`SYN=1`，序列号`seq=100`。**要消耗一个序号`seq`**
- **第二次握手：** 服务端收到客户端发过来的报文后，发现`SYN=1`，知道这是一个连接请求，于是将客户端的起始序列号`100`存起来，并且随机生成一个服务端的起始序列号(比如是`300`)。然后给客户端回复一段报文，回复报文包含`SYN`和`ACK`标志(也就是`SYN=1,ACK=1`)、序列号`seq=300`、确认号`ack=101`(客户端发过来的序列号`+1`)。
- **第三次握手：** 客户端收到服务端的回复后发现`ACK=1`并且`ack=101`,于是知道服务端已经收到了序列号为`100`的那段报文；同时发现`SYN=1`，知道了服务端同意了这次连接，于是就将服务端的序列号`300`给存下来。然后客户端再回复一段报文给服务端，报文包含`ACK`标志位(`ACK=1`)、`ack=301`(服务端序列号`+1`)、`seq=101`(第一次握手时发送报文是占据一个序列号的，所以这次`seq`就从`101`开始，需要注意的是不携带数据的`ACK`报文是不占据序列号的，所以后面第一次正式发送数据时`seq`还是`101`)。当服务端收到报文后发现`ACK=1`并且`ack=301`，就知道客户端收到序列号为`300`的报文了，就这样客户端和服务端通过`TCP`建立了连接。

### 四次挥手
> 四次挥手的目的是关闭一个连接

![img](/dovis-blog/other/13.jpg)

> 比如客户端初始化的序列号`ISA=100`，服务端初始化的序列号`ISA=300`。`TCP`连接成功后客户端总共发送了`1000`个字节的数据，服务端在客户端发`FIN`报文前总共回复了`2000`个字节的数据。

- **第一次挥手:** 当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含`FIN`标志位(`FIN=1`)、序列号`seq=1101`(`100+1+1000`，其中的`1`是建立连接时占的一个序列号)。需要注意的是客户端发出`FIN`报文段后只是不能发数据了，但是还可以正常收数据；另外`FIN`报文段即使不携带数据也要占据一个序列号。
- **第二次挥手：** 服务端收到客户端发的`FIN`报文后给客户端回复确认报文，确认报文包含`ACK`标志位(`ACK=1`)、确认号`ack=1102`(客户端`FIN`报文序列号`1101+1`)、序列号`seq=2300`(`300+2000`)。此时服务端处于关闭等待状态，而不是立马给客户端发`FIN`报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。
- **第三次挥手：** 服务端将最后数据(比如`50`个字节)发送完毕后就向客户端发出连接释放报文，报文包含`FIN`和`ACK`标志位(`FIN=1,ACK=1`)、确认号和第二次挥手一样`ack=1102`、序列号`seq=2350(2300+50)`
- **第四次挥手：** 客户端收到服务端发的`FIN`报文后，向服务端发出确认报文，确认报文包含`ACK`标志位(`ACK=1`)、确认号`ack=2351`、序列号`seq=1102`。注意客户端发出确认报文后不是立马释放`TCP`连接，而是要经过`2MSL`(最长报文段寿命的`2`倍时长)后才释放`TCP`连接。而服务端一旦收到客户端发出的确认报文就会立马释放`TCP`连接，所以服务端结束`TCP`连接的时间要比客户端早一些。

::: tip
`SYN`报文：起标识作用的家伙。当`SYN=1`而`ACK=0`时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使用`SYN=1`和`ACK=1`，因此`SYN`置于`1`就表示这是一个连接请求或连接接受报文。

`ACK`报文：`TCP`协议规定，只有`ACK=1`时有效，也规定连接建立后所有发送的报文的`ACK`必须为`1`

`FIN`报文：`FIN=1`表示此报文段的发送方的数据已经发送完毕，请求释放运输连接
:::

## `TCP`常见面试题
1. `TCP`建立连接，客户端突然出现故障？
> `TCP`设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为`2`小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔`75`秒钟发送一次。若一连发送`10`个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

2. 
![img](/dovis-blog/other/13.png)