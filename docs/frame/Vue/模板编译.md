# 模板编译原理
> vue提供了模板语法，允许我们声明式地描述状态和`DOM`之间的绑定关系，然后通过模板来生成真实`DOM`并将其呈现在用户界面上。在底层实现上，vue会将模板编译成虚拟`DOM`渲染函数。当应用内部的状态发生变化时，vue可以结合响应式系统，聪明地找出最小数量的组件进行重新渲染以及最少量地进行`DOM`操作。

在vue中创建`Html`并不是只有模板这一种途径，我们既可以手动写渲染函数来创建，也可以使用`JSX`来创建。渲染函数是创建`HTML`最原始的方法。**模板最终会通过编译转换成渲染函数，渲染函数执行后，会得到一份`vnode`用于虚拟`DOM`渲染。所以模板编译其实是配合虚拟`DOM`进行渲染。**

渲染函数的作用是每次执行它，它就会使用当前最新的状态生成一份新的`vnode`，然后使用这个`vnode`进行渲染。

## 将模板编译成渲染函数
> 先将模板解析成`AST`（抽象语法树），然后使用抽象语法树生成渲染函数。

::: tip
由于静态节点不需要总是重新渲染，所以生成`AST`之后，生成渲染函数之前这个阶段，需要做一个操作，那就是遍历一遍抽象语法树，给所有静态节点做一个标记，这样在虚拟`DOM`
中更新节点时，如果发现这个节点有标记就不会重新渲染它。
:::

所以模板编译大体分为三部分：
- 将模板解析为`AST`--解析器
- 遍历抽象语法树标记静态节点--优化器
- 使用抽象语法树生成渲染函数--代码生成器

## 解析器
在解析器内部分成很多小解析器：包括过滤器解析器，文本解析器和`HTML`解析器，然后通过一条主线将这些解析器组装在一起。
- 过滤器解析器
> 用来解析过滤器的

- 文本解析器
> 用来解析带变量的文本

- `HTML`解析器
> 解析模板，每当解析到`HTML`标签的开始位置，结束位置，文本或者注释，都会触发钩子函数，然后将相关信息通过参数传递出来。

::: tip
主线上做的事情就是监听`HTML`解析器。每当触发钩子函数时，就生成一个对应的抽象语法树节点。生成抽象语法树前，会根据类型使用不同的方式生成不同抽象语法树。例如，如果是文本节点，就生成文本类型的`AST`。当解析器不再触发钩子函数时，就说明所有模板都解析完毕，所有类型的节点都在钩子函数中构建完成，即`AST`构建完成。
:::

### 解析器内部原理
> 钩子函数`start`有三个参数，分别是`tag/attrs/unary`。分别说明标签名，标签的属性和是否是自闭合标签。而文本节点的钩子函数`chars`和注释节点的钩子函数`comment`都只有一个参数，只有`text`。这是因为构建元素节点时需要知道标签名，属性和自闭合标识，而构建注释节点和文本节点只需要知道文本即可。

```html
<div>
    <h1>
    我是林嘉恒
    </h1>
    <p>
    今年24岁
    </p>
</div>
```
::: tip
这个模板被解析成`AST`过程需要注意的点：
- 利用一个栈来记录层级关系
- 基于`HTML`解析器的逻辑，我们可以在每次触发钩子函数`start`时，把当前构建的节点推入栈中；每当触发钩子函数`end`时就会从栈中弹出一个节点。
- 这样就可以保证每当触发钩子函数`start`时，栈中最后一个节点就是当前正在构建的节点的父节点。
- 模板中开始位置的一些空格，会触发文本节点的钩子函数，在钩子函数里会忽略这些空格。同时会在模板中将这些空格截取掉。
- 解析到文本节点时，栈中最后一个节点就是其父节点，将文本节点添加到该父节点的子节点中。由于文本节点没有子节点所以文本节点不会被推入到栈中。
- 栈空时，就得到一个完整的带层级关系的抽象语法树。
:::

### `HTML`解析器
解析`HTML`模板的过程就是循环的过程，简单来说就是用`HTML`模板字符串来循环，每轮循环都从HTML模板中截取一小段字符串，然后重复上述过程，直到HTML模板被截成一个空字符串时循环结束。

::: tip
**那么又是如何在每一轮循环中都知道要截取哪些字符串？**
:::

### 文本解析器
文本解析器的作用是解析文本。奇怪的是文本不是已经在`HTML`解析器中被解析出来了么？准确来说文本解析器是对`HTML`解析器解析出来的文本进行二次加工。因为文本分两种类型，一种是纯文本，另一种是带变量的文本。

::: tip
在vue中我们可以使用变量来填充模板。而`HTML`解析器在解析文本时，并不会区分文本是否带变量的文本。如果是纯文本不需要进行任何处理；但如果是带变量的文本，那么需要使用文本解析器进一步解析。因为带变量的文本在使用虚拟`DOM`进行渲染时，需要将变量替换成变量的值。

在文本解析器中，第一步做的事情就是使用正则表达式来判断文本是否为带变量的文本，也就是检查文本中是否包含`{{xxx}}`这样的语法。如果是纯文本，则直接返回`undefined`；如果是带变量的文本，再进行二次加工。

如何解决带变量的文本呢：**使用正则表达式匹配出文本中的变量，先把变量左边的文本添加到数组中，然后把变量改成`_s(x)`这样的形式也添加到数组中。如果变量后面有变量则重复这动作。这时有一个数组，数组元素和文本顺序一致，此时将数组元素用`+`连起来变成字符串，就可以得到最后结果**。
:::

```js
// _s(x)就是toString别名
function toString(val) {
    return val == null
        ? ''
        : typeof val === 'object'
        ? JSON.stringify(val,null,2)
        : String(val)
}
```

## 优化器
优化器的目标遍历`AST`，检测出所有静态子树（永远都不会发生变化的`DOM`节点）并打上标记。当`AST`中静态子树被打上标记后，每次重新渲染时就不需要为打上标记的静态节点创建新的虚拟节点，而是直接克隆已经存在的虚拟节点。**静态子树是指的是那些在`AST`中永远都不会发生变化的节点**

+ 标记静态子树有两点好处：
    - 每次重新渲染时，不需要为静态子树创建新节点；
    - 在虚拟`DOM`中打补丁`patching`的过程可以跳过。

::: tip
每次重新渲染都会使用最新的状态生成一份全新的`VNode`与旧的`VNode`进行对比。而生成`VNode`的过程中，如果发现一个节点被标记为静态子树，那么除了首次渲染会生成节点之外，在重新渲染时并不会生成新的子节点树，而是克隆已存在的静态子树。

打补丁`patch`过程中，如果两个节点都是静态子树，就不需要进行对比与更新`DOM`的操作，直接跳过。因为静态子树是不可变的，不需要对比就知道不可能发生变化。
:::

+ 优化器内部实现两个步骤：
    - 在`AST`中找出所有静态节点并打上标记
    - 在`AST`中找出所有静态根节点并打上标记

> 如果一个节点下面所有子节点都是静态节点，并且父级是动态节点，那么它就是静态根节点。

## 代码生成器
代码生成器是模板函数编译最后一步，作用是将`AST`转换成渲染函数中的内容，这个内容可以称为代码字符串。
```js
<p title='Berwin' @click='c'>1</p>

// 生成的代码字符串
`with(this){return _c('p',{attrs: {"titile":"Berwin"}, on: {"clcik":c}}, [_v("1")]}`

//格式化后
with(this) {
    return _c(
        'p',
        {
            attrs:{"title":"Berwin"},
            on:{"click":c}
        },
        [_v("1")]
    )
}
```

::: tip
渲染函数之所以可以生成`vnode`，是因为代码字符串中会有很多函数调用（如`_c/_v`），这些函数是虚拟DOM提供创建`vnode`的方法。`vnode`有很多种类型，不同的类型对应不同的创建方法，所以代码字符串中的`_c/_v`其实都是创建`vnode`的方法，只是创建的`vnode`的类型不同。例如，`_c`可以创建元素类型的`vnode`，而`_v`可以创建文本类型的`vnode`。

代码字符串中的`_c`其实是`createElement`的别名。`createElement`是虚拟`DOM`中提供的方法，作用是创建虚拟节点，有三个参数：
- 标签名
- 一个包含模板相关属性的数据对象
- 子节点列表

> 这也知道了渲染函数可以生成`VNode`的原因：渲染函数其实是执行了`createElement`，而`createElement`可以创建一个`VNode`
:::

> 代码生成器其实就是字符串拼接的过程。通过递归`AST`来生成字符串，最先生成根节点，然后在子节点字符串生成后，将其拼接在根节点的参数中，子节点的子节点拼接在子节点的参数中，这样一层一层地拼接，直到最后拼接成完整的字符串。会将字符串在`with`中返回给调用者。