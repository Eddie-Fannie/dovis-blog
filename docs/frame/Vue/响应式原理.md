# 响应式原理
> 当一个`Vue`实例创建时，`vue`会遍历`data`选项的属性，用 `Object.defineProperty` 将它们转为`getter/setter`并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的`watcher`程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的`setter`被调用时，会通知`watcher`重新计算，从而致使它关联的组件得以更新。

1. `getter`收集依赖，`setter`触发依赖
```js
function defineReactive(data, key, val) {
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            return val;
        },
        set: function(newVal) {
            if(val === newVal) {
                return
            }
            val = newVal
        }
    })
}
```
> 定义一个响应式数据。也就是这个函数中进行变化追踪，封装后只需要传递`data key val`就行。

## 收集依赖到哪里
依赖收集器`Dep`，可以收集依赖，删除依赖和向依赖发送通知
```js
var Dep = function Dep () {
    this.id = uid++;
    this.subs = [];
  };

  Dep.prototype.addSub = function addSub (sub) {
    this.subs.push(sub);
  };

  Dep.prototype.removeSub = function removeSub (sub) {
    remove(this.subs, sub);
  };

  Dep.prototype.depend = function depend () {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };

  Dep.prototype.notify = function notify () {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };

  function remove(arr, item) {
      if(arr.length) {
          const index = arr.indexOf(item)
          if(index > -1) {
              return arr.splice(index, 1)
          }
      }
  }
```

之后再改造一下`defineReactive`
```js
function defineReactive(data, key,val) {
    let dep = new Dep(); 
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            dep.depend() // getter里面收集依赖
            return val;
        },
        set: function(newVal) {
            if(val === newVal) {
                return
            }
            val = newVal
            dep.notify()
        }
    })
}
```
所以收集依赖到`Dep`中去。

## 收集谁（谁是依赖）--订阅者
`Watcher`，换句话说是当依赖发生变化通知`Watcher`
> 依赖注入到`Dep`中后，每当数据发生变化时，就会让依赖列表中的所有依赖循环触发`update`方法，也就是`Watcher`中的`update`方法。而`update`方法会执行参数中的回调函数，将`value/oldValue`传到参数中。

## 递归侦测所有数据
封装一个`Observer`类。这个类的作用是将一个数据内的所有属性（包括子属性）都转换成`getter/setter`形式，然后追踪它们的变化：
```js
export class Observer {
  constructor (value: any) {
    this.value = value
    if (!Array.isArray(value)) {
      this.walk(value)
    }
  }

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i], obj[keys[i]])
    }
  }
}

function defineReactive(data, key,val) {
    // 新增 递归子属性
    if(typeof val === 'object') {
        new Observer(val)
    }
    let dep = new Dep(); 
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            dep.depend()
            return val;
        },
        set: function(newVal) {
            if(val === newVal) {
                return
            }
            val = newVal
            dep.notify()
        }
    })
}
```

::: tip
`Vue`中通过`Object.defineProperty`来将对象的`key`转换成`getter/setter`，但是只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。

> `Watcher`原理是先把自己设置到全局唯一的指定位置（如`window.target`），然后读取数据。因为读取了数据，所以会触发这个数据的`getter`。接着在`getter`中就会从全局唯一的那个位置读取当前正在读取数据的`Watcher`，并把这个`Watcher`收集到`Dep`中去。这样订阅者就可以主动订阅任意一个数据的变化。

- `Data`通过`Observer`转换成`getter/setter`形式追踪变化。
- 当外界通过`Watcher`读取数据时，会触发`getter`从而将`Watcher`添加到依赖中。
- 当数据发生变化时，会触发`setter`，从而向`Dep`中的依赖`Watcher`发送通知。
- `Watcher`接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数。
:::