# 响应式原理（双向绑定）
> 当一个`Vue`实例创建时，`vue`会遍历`data`选项的属性，用 `Object.defineProperty` 将它们转为`getter/setter`并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的`watcher`程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的`setter`被调用时，会通知`watcher`重新计算，触发相应的监听回调。从而致使它关联的组件得以更新。

1. `getter`收集依赖，`setter`触发依赖
```js
function defineReactive(data, key, val) {
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            return val;
        },
        set: function(newVal) {
            if(val === newVal) {
                return
            }
            val = newVal
        }
    })
}
```
> 定义一个响应式数据。也就是这个函数中进行变化追踪，封装后只需要传递`data key val`就行。

## 收集依赖到哪里
依赖收集器`Dep`，可以收集依赖，删除依赖和向依赖发送通知
```js
var Dep = function Dep () {
    this.id = uid++;
    this.subs = [];
  };

  Dep.prototype.addSub = function addSub (sub) {
    this.subs.push(sub);
  };

  Dep.prototype.removeSub = function removeSub (sub) {
    remove(this.subs, sub);
  };

  Dep.prototype.depend = function depend () {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };

  Dep.prototype.notify = function notify () {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };

  function remove(arr, item) {
      if(arr.length) {
          const index = arr.indexOf(item)
          if(index > -1) {
              return arr.splice(index, 1)
          }
      }
  }
```

之后再改造一下`defineReactive`
```js
function defineReactive(data, key,val) {
    let dep = new Dep(); 
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            dep.depend() // getter里面收集依赖
            return val;
        },
        set: function(newVal) {
            if(val === newVal) {
                return
            }
            val = newVal
            dep.notify()
        }
    })
}
```
所以收集依赖到`Dep`中去。

## 收集谁（谁是依赖）--订阅者
`Watcher`，换句话说是当依赖发生变化通知`Watcher`
> 依赖注入到`Dep`中后，每当数据发生变化时，就会让依赖列表中的所有依赖循环触发`update`方法，也就是`Watcher`中的`update`方法。而`update`方法会执行参数中的回调函数，将`value/oldValue`传到参数中。

## 递归侦测所有数据
封装一个`Observer`类。这个类的作用是将一个数据内的所有属性（包括子属性）都转换成`getter/setter`形式，然后追踪它们的变化：
```js
export class Observer {
  constructor (value: any) {
    this.value = value
    if (!Array.isArray(value)) {
      this.walk(value)
    }
  }

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i], obj[keys[i]])
    }
  }
}

function defineReactive(data, key,val) {
    // 新增 递归子属性
    if(typeof val === 'object') {
        new Observer(val)
    }
    let dep = new Dep(); // 为每个属性创建Dep依赖搜集
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            dep.depend()
            return val;
        },
        set: function(newVal) {
            if(val === newVal) {
                return
            }
            val = newVal
            dep.notify() // set一旦触发就依赖更新通知
        }
    })
}
```

::: tip
`Vue`中通过`Object.defineProperty`来将对象的`key`转换成`getter/setter`，但是只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。

> `Watcher`原理是先把自己设置到全局唯一的指定位置（如`window.target`），然后读取数据。因为读取了数据，所以会触发这个数据的`getter`。接着在`getter`中就会从全局唯一的那个位置读取当前正在读取数据的`Watcher`，并把这个`Watcher`收集到`Dep`中去。这样订阅者就可以主动订阅任意一个数据的变化。

- `Data`通过`Observer`转换成`getter/setter`形式追踪变化。
- 当外界通过`Watcher`读取数据时，会触发`getter`从而将`Watcher`添加到依赖中。
- 当数据发生变化时，会触发`setter`，从而向`Dep`中的依赖`Watcher`发送通知。
- `Watcher`接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数。
:::

> 模板渲染解析时对应绑定指令，此时会调用订阅者初始化（`watcher`中的`get()`方法，去触发对应属性在发布者`observer`的`getter`，发布者会判断是不是通过订阅者初始化调用的，只有是才有通过`Dep`收集依赖。发布者通过`depend`通知`Dep`类收集。此后每次的数据更新都会通过发布者的`setter`去触发`Dep`类的回调`update`执行收集依赖的所有方法，更新订阅者的所有状态及更新视图。

## 双向绑定的优点
+ 基于数据劫持/依赖收集 的双向绑定优点：
  - 不需要显示调用，利用数据劫持+发布订阅，可以直接通知变化并且驱动视图更新
  - 直接得到精确的变化数据，劫持了属性`setter`，属性值改变我们可以精确获得变化的内容`newVal`，不需要额外的`diff`操作。

## vue2.0对比vue3.0
+ `Object.defineProperty`缺点：
  - 不能监听数组，没有`getter/setter`。数组长度太长性能负担大。
  - 只能监听属性，而不是整个对象。需要遍历属性。
  - 只能监听属性变化，不能监听增删属性。

+ `proxy`优缺点：
  - 可以监听数组
  - 监听整个对象
  - 13种拦截方法
  - 返回新对象而不是直接修改原对象，更符合`immutable`

  - 兼容性不好，无法用`polyfill`磨平