# 对象的深浅拷贝
> 针对深拷贝，需要使用其他方法，因为`Object.assign()`拷贝的是可枚举属性值。假如源值是一个对象的引用，它仅仅会复制其引用值。

**例子：**
```js
const log = console.log;
function test() {
    let obj1 = { a: 0 , b: { c: 0}}; 
    let obj2 = Object.assign({}, obj1); 
    log(JSON.stringify(obj2));
    // { a: 0, b: { c: 0}} 

    obj1.a = 1; 
    log(JSON.stringify(obj1));
    // { a: 1, b: { c: 0}} 
    log(JSON.stringify(obj2));
    // { a: 0, b: { c: 0}} 

    obj2.a = 2; 
    log(JSON.stringify(obj1));
    // { a: 1, b: { c: 0}} 
    log(JSON.stringify(obj2));
    // { a: 2, b: { c: 0}}

    obj2.b.c = 3; 
    log(JSON.stringify(obj1));
    // { a: 1, b: { c: 3}} 
    log(JSON.stringify(obj2));
    // { a: 2, b: { c: 3}}

    // Deep Clone 
    obj1 = { a: 0 , b: { c: 0}}; 
    let obj3 = JSON.parse(JSON.stringify(obj1)); 
    obj1.a = 4; 
    obj1.b.c = 4; 
    log(JSON.stringify(obj3));
    // { a: 0, b: { c: 0}}
}
test()
```