# 模块化
> 模块化解决了命名冲突问题，可以提高代码的复用率，提高代码的可维护性。

+ 模块化好处；
    - 避免命名冲突
    - 更好的分离，按需加载
    - 更高复用性
    - 高可维护性

## 模块化方式
1. 最初实现模块化方式使用函数进行封装，将不同功能的代码实现封装到不同的函数中，通常就是一个文件为一个模块，有自己的作用域，只向外暴露特定的变量和函数。**这种方式容易发生命名冲突和数据不安全**
2. 采取立即执行函数：立即执行函数中的匿名函数中有独立的词法作用域，避免了外界访问此作用域的变量。**通过函数作用域解决了命名冲突，污染全局作用域的问题**，不过不能直接访问到内部的变量，是这种方式的一个弊端

```js
// module.js
(function(window) {
    let name = 'linjiaheng'
    //暴露接口来访问数据
    function a() {
        console.log(`name:${name}`)
    }
    // 暴露接口
    window.myModule = { a }
})(window)

<script src="module.js"></script>
<script>
myModule.name = 'xixi' //无法访问
myModule.foo() // linjiaheng
</script>
```
3. `CommonJS`规范
4. `AMD和CMD`
5. `ES6`

::: tip
+ 模块化发展历程
    - 早期假模块化时代
    > 早期借助函数作用域来模拟模块化，称其为函数模式。这样存在命名冲突的风险。这没有从根本上解决模块的问题，只是将代码分成了更小的函数单元而已。所以有了第二种模式：利用对象，实现命名空间的概念。这样会导致数据不安全，可以被开发者修改。通过立即执行函数构造一个私有作用域，再通过闭包将需要对外暴露的数据和接口输出。
    - 规范标准时代：`CommonJS/AMD/CMD/UMD`
    - ES原生时代
:::

## 浏览器模块加载实现
1. 传统方法
浏览器通过`script`标签加载脚本。这种方式会造成浏览器堵塞，所以浏览器允许脚本异步加载：
```js
<script src="" defer></script>

<script src="" async></script>
```
> 渲染引擎遇到这命令会开始下载外部脚本，但不会等他下载和执行，而是直接执行后面的命令。

::: tip
`defer`等到整个页面正常渲染结束才会执行，渲染完再执行。**多个`defer`脚本，会按照在页面出现的顺序加载**
`async`一旦下载完成，渲染引擎就会中断渲染，执行这个脚本之后再继续渲染。下载完就执行。**不能保证加载顺序**
:::

2. 浏览器加载ES6模块时，要在`script`标签中加入`type='module'`。浏览器都是异步加载了，不会堵塞浏览器。等到整个页面渲染完再执行模块脚本，等同于添加了`defer`属性。`async`属性也可以在ES6中添加使用。

## ES6和CommonJS模块的差异
- CommonJS模块输出的是一个值的复制，ES6模块输出的是值的引用。
- CommonJS模块是运行时加载，ES6模块是编译时输出接口
> 第二个差异是因为CommonJS加载的是一个对象（`module.exports`）该对象只有在脚本运行结束时才会生成。而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
>
> 第一个差异：值的复制，也就是说一旦输出一个值，模块内部的变化就不会影响到这个值，CommonJS会产生缓存。ES6的运行机制却不同，表现在遇到模块加载命令`import`就会生成一个只读引用，等到脚本真正执行时，再根据这个只读引用到被加载的模块中取值。**ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块**，由于ES6的输入的模块变量只是一个符号连接，所以这个变量为只读，对它重新赋值就会报错，类似定义了一个`const`变量。