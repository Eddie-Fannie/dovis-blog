(window.webpackJsonp=window.webpackJsonp||[]).push([[225],{499:function(e,t,r){"use strict";r.r(t);var a=r(10),v=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"amd和cmd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#amd和cmd"}},[e._v("#")]),e._v(" AMD和CMD")]),e._v(" "),t("h2",{attrs:{id:"amd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#amd"}},[e._v("#")]),e._v(" AMD")]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("AMD （ Asynchronous Module Definition ）")]),e._v('，即 "异步模块定义" 。它主要采用异步方式加载模块，模块的加载不影响它后边语句的运行。所加载的模块，都会定义在回调函数中，加载完成，再执行回调函数。')])]),e._v(" "),t("h2",{attrs:{id:"cmd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cmd"}},[e._v("#")]),e._v(" CMD")]),e._v(" "),t("blockquote",[t("p",[e._v("加载模块时可以通过同步的形式("),t("code",[e._v("require")]),e._v(")，也可以通过异步的形式"),t("code",[e._v("require.async")])])]),e._v(" "),t("h3",{attrs:{id:"使用方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用方式"}},[e._v("#")]),e._v(" 使用方式")]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("AMD")]),e._v("利用"),t("code",[e._v("require.js")]),e._v("。通过"),t("code",[e._v("define")]),e._v("方法将代码定义为模块；通过"),t("code",[e._v("require")]),e._v("方法实现代码的模块加载。"),t("code",[e._v("define/require")]),e._v("就是"),t("code",[e._v("require.js")]),e._v("在全局注入的函数。")])]),e._v(" "),t("h2",{attrs:{id:"amd和cmd的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#amd和cmd的区别"}},[e._v("#")]),e._v(" AMD和CMD的区别")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("AMD")]),e._v(" 依赖前置， js 很方便的就知道要加载的是哪个模块了，因为已经在 "),t("code",[e._v("define")]),e._v(" 的"),t("code",[e._v("dependencies")]),e._v(" 参数中就定义好了，会立即加载它。")]),e._v(" "),t("li",[t("code",[e._v("CMD")]),e._v(" 是就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块。只有在用到某个模块的时候再去 "),t("code",[e._v("require")]),e._v(" 。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);