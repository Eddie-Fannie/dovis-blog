(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{388:function(t,s,e){"use strict";e.r(s);var v=e(10),_=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"工作中使用git遇到的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#工作中使用git遇到的问题"}},[t._v("#")]),t._v(" 工作中使用Git遇到的问题")]),t._v(" "),s("h2",{attrs:{id:"_1-合并之前提交或保存修改"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-合并之前提交或保存修改"}},[t._v("#")]),t._v(" 1.合并之前提交或保存修改")]),t._v(" "),s("blockquote",[s("p",[s("code",[t._v("commit your changes or stash them before you can merge")]),t._v("\n这种情况是因为别人修改刘文件并提交，你修改的文件涉及到别人修改到文件。"),s("code",[t._v("git pull")]),t._v("会出现以上情况。")])]),t._v(" "),s("ul",[s("li",[t._v("解决办法：\n"),s("ul",[s("li",[t._v("放弃修改，可以先代码做备份再回退，继续"),s("code",[t._v("git pull")])]),t._v(" "),s("li",[t._v("利用"),s("code",[t._v("stash")]),t._v("数据存储（顺序："),s("code",[t._v("git stash ---\x3e git pull ---\x3e git stash pop")]),t._v(")")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("git stash")]),t._v("：备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到"),s("code",[t._v("Git")]),t._v("栈中。")]),t._v(" "),s("li",[s("code",[t._v("git stash pop")]),t._v(": 从"),s("code",[t._v("Git")]),t._v("栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个"),s("code",[t._v("Stash")]),t._v("的内容，所以用栈来管理，"),s("code",[t._v("pop")]),t._v("会从最近的一个"),s("code",[t._v("stash")]),t._v("中读取内容并恢复。")]),t._v(" "),s("li",[s("code",[t._v("git stash list")]),t._v(": 显示"),s("code",[t._v("Git")]),t._v("栈内的所有备份，可以利用这个列表来决定从那个地方恢复。")]),t._v(" "),s("li",[s("code",[t._v("git stash clear")]),t._v(": 清空"),s("code",[t._v("Git")]),t._v("栈。此时使用图形化工具会发现，原来"),s("code",[t._v("stash")]),t._v("的哪些节点都消失了。")])])]),t._v(" "),s("ul",[s("li",[t._v("放弃本地修改，直接覆盖")])]),t._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" reset "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--hard")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" pull\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])])])]),t._v(" "),s("h2",{attrs:{id:"_2-合并代码到fork仓库-出现冲突"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-合并代码到fork仓库-出现冲突"}},[t._v("#")]),t._v(" 2. 合并代码到"),s("code",[t._v("fork")]),t._v("仓库，出现冲突")]),t._v(" "),s("ul",[s("li",[t._v("解决办法：\n"),s("ul",[s("li",[s("code",[t._v("fork")]),t._v("仓库新建一个临时分支")]),t._v(" "),s("li",[t._v("跟原本的仓库建立联系："),s("code",[t._v("git remote add upstream xxxx")]),t._v(" (xxxx指原本仓库地址)")]),t._v(" "),s("li",[t._v("拉取原本仓库"),s("code",[t._v("source branch")]),t._v("到"),s("code",[t._v("fork")]),t._v("仓库本地："),s("code",[t._v("git fetch upstream test:upstream-test")]),t._v(" (重命名成"),s("code",[t._v("upstream-test")]),t._v("，避免跟自身"),s("code",[t._v("test")]),t._v("分支冲突)")]),t._v(" "),s("li",[t._v("然后合入并解决冲突，合入："),s("code",[t._v("git merge upstream-test")])]),t._v(" "),s("li",[t._v("把临时分支推到远程")])])])])])}),[],!1,null,null,null);s.default=_.exports}}]);