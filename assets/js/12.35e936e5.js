(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{285:function(v,_,e){"use strict";e.r(_);var t=e(10),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"浏览器渲染机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染机制"}},[v._v("#")]),v._v(" 浏览器渲染机制")]),v._v(" "),_("h2",{attrs:{id:"进程-线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程-线程"}},[v._v("#")]),v._v(" 进程/线程")]),v._v(" "),_("blockquote",[_("p",[v._v("进程（"),_("code",[v._v("process")]),v._v("）：启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。\n线程（"),_("code",[v._v("thread")]),v._v("）是"),_("code",[v._v("CPU")]),v._v("调度和分配的基本单位，可以和同一个进程的其他线程共享进程所拥有的全部资源，线程是不能单独存在的，它是由进程来启动和管理的。")])]),v._v(" "),_("p",[v._v("总结来说，进程和线程之间的关系有以下 "),_("code",[v._v("4")]),v._v(" 个特点：")]),v._v(" "),_("ol",[_("li",[v._v("进程中的任意一线程执行出错，都会导致整个进程的崩溃。")]),v._v(" "),_("li",[v._v("线程之间共享进程中的数据。")]),v._v(" "),_("li",[v._v("当一个进程关闭之后，操作系统会回收进程所占用的内存。")]),v._v(" "),_("li",[v._v("进程之间的内容相互隔离。")])]),v._v(" "),_("blockquote",[_("p",[v._v("最新的 "),_("code",[v._v("Chrome")]),v._v(" 浏览器包括："),_("code",[v._v("1")]),v._v(" 个浏览器（"),_("code",[v._v("Browser")]),v._v("）主进程、"),_("code",[v._v("1")]),v._v(" 个 "),_("code",[v._v("GPU")]),v._v(" 进程、"),_("code",[v._v("1")]),v._v(" 个网络（"),_("code",[v._v("NetWork")]),v._v("）进程、多个渲染进程和多个插件进程。")])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("p",[v._v("浏览器地址输入一个"),_("code",[v._v("URL")]),v._v("，浏览器根据"),_("code",[v._v("DNS")]),v._v("服务器得到域名的"),_("code",[v._v("IP")]),v._v("地址，这个时候浏览器进程会向这个"),_("code",[v._v("IP")]),v._v("地址发送请求，获取"),_("code",[v._v("HTML")]),v._v("内容。然后将这些内容交给渲染进程。渲染进程解析内容，解析遇到的请求网络的资源又返回来交给浏览器进程进行加载，同时通知主进程（浏览器进程），需要插件进程加载插件资源，执行插件代码。解析完成后，渲染进程得到图像帧，并交给"),_("code",[v._v("GPU")]),v._v("进程，将其转化为图像显示屏幕。"),_("RouterLink",{attrs:{to:"/basis/JavaScript/Event-Loop.html#浏览器包含了哪些进程"}},[v._v("四种进程介绍")])],1)]),v._v(" "),_("blockquote",[_("p",[v._v("首先，当我们是要浏览一个网页，我们会在浏览器的地址栏里输入"),_("code",[v._v("URL")]),v._v("，这个时候"),_("code",[v._v("Browser Process")]),v._v("会向这个"),_("code",[v._v("URL")]),v._v("发送请求，获取这个"),_("code",[v._v("URL")]),v._v("的"),_("code",[v._v("HTML")]),v._v("内容，然后将"),_("code",[v._v("HTML")]),v._v("交给"),_("code",[v._v("Renderer Process")]),v._v("，"),_("code",[v._v("Renderer Process")]),v._v("解析"),_("code",[v._v("HTML")]),v._v("内容，解析遇到需要请求网络的资源又返回来交给"),_("code",[v._v("Browser Process")]),v._v("进行加载，同时通知"),_("code",[v._v("Browser Process")]),v._v("，需要"),_("code",[v._v("Plugin Process")]),v._v("加载插件资源，执行插件代码。解析完成后，"),_("code",[v._v("Renderer Process")]),v._v("计算得到图像帧，并将这些图像帧交给"),_("code",[v._v("GPU Process")]),v._v("，"),_("code",[v._v("GPU Process")]),v._v("将其转化为图像显示屏幕。")])]),v._v(" "),_("h3",{attrs:{id:"浏览器进程模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器进程模式"}},[v._v("#")]),v._v(" 浏览器进程模式")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("p",[v._v("Chrome浏览器多进程的好处：")]),v._v(" "),_("ol",[_("li",[v._v("更高的容错性。当今"),_("code",[v._v("WEB")]),v._v("应用中，"),_("code",[v._v("HTML，JavaScript")]),v._v("和"),_("code",[v._v("CSS")]),v._v("日益复杂，这些跑在渲染引擎的代码，频繁的出现BUG，而有些"),_("code",[v._v("BUG")]),v._v("会直接导致渲染引擎崩溃，多进程架构使得每一个渲染引擎运行在各自的进程中，相互之间不受影响，也就是说，当其中一个页面崩溃挂掉之后，其他页面还可以正常的运行不收影响。")]),v._v(" "),_("li",[v._v("更高的安全性和沙盒性（"),_("code",[v._v("sanboxing")]),v._v("）。渲染引擎会经常性的在网络上遇到不可信、甚至是恶意的代码，它们会利用这些漏洞在你的电脑上安装恶意的软件，针对这一问题，浏览器对不同进程限制了不同的权限，并为其提供沙盒运行环境，使其更安全更可靠。")]),v._v(" "),_("li",[v._v("更高的响应速度。在单进程的架构中，各个任务相互竞争抢夺"),_("code",[v._v("CPU")]),v._v("资源，使得浏览器响应速度变慢，而多进程架构正好规避了这一缺点。")])])]),v._v(" "),_("blockquote",[_("p",[v._v("为了节省内存，Chrome提供了四种进程模式（"),_("code",[v._v("Process Models")]),v._v("），不同的进程模式会对 "),_("code",[v._v("tab")]),v._v(" 进程做不同的处理。")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("Process-per-site-instance (default)")]),v._v(" - 同一个 "),_("code",[v._v("site-instance")]),v._v(" 使用一个进程")])]),v._v(" "),_("blockquote",[_("p",[v._v("当你打开一个 "),_("code",[v._v("tab")]),v._v(" 访问 "),_("code",[v._v("a.baidu.com")]),v._v(" ，然后再打开一个 "),_("code",[v._v("tab")]),v._v(" 访问 "),_("code",[v._v("b.baidu.com")]),v._v("，这两个 "),_("code",[v._v("tab")]),v._v(" 会使用两个进程。而如果你在 "),_("code",[v._v("a.baidu.com")]),v._v(" 中，通过JS代码打开了 "),_("code",[v._v("b.baidu.com")]),v._v(" 页面，这两个 tab 会使用同一个进程。")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("Process-per-site")]),v._v("：同一个"),_("code",[v._v("site")]),v._v("一个进程")]),v._v(" "),_("li",[_("code",[v._v("Process-per-tab")]),v._v("：每个"),_("code",[v._v("tab")]),v._v("使用一个进程")]),v._v(" "),_("li",[_("code",[v._v("single Process")]),v._v("：所有"),_("code",[v._v("tab")]),v._v("共用一个进程")])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("site")]),v._v(" 指的是相同的 "),_("code",[v._v("registered domain name")]),v._v("(如："),_("code",[v._v("google.com")]),v._v(" ，"),_("code",[v._v("bbc.co.uk")]),v._v(")和"),_("code",[v._v("scheme")]),v._v(" (如："),_("code",[v._v("https://")]),v._v(")。比如"),_("code",[v._v("a.baidu.com")]),v._v("和"),_("code",[v._v("b.baidu.com")]),v._v("就可以理解为同一个 "),_("code",[v._v("site")]),v._v("（注意这里要和 "),_("code",[v._v("Same-origin policy")]),v._v(" 区分开来，同源策略还涉及到子域名和端口）。")]),v._v(" "),_("li",[_("code",[v._v("site-instance")]),v._v(" 指的是一组 "),_("code",[v._v("connected pages from the same site")]),v._v("，这里 "),_("code",[v._v("connected")]),v._v(" 的定义是 "),_("code",[v._v("can obtain references to each other in script code")]),v._v(" 怎么理解这段话呢。满足下面两情况并且打开的新页面和旧页面属于上面定义的同一个 "),_("code",[v._v("site")]),v._v("，就属于同一个 "),_("code",[v._v("site-instance")]),v._v(" "),_("ul",[_("li",[v._v("用户通过"),_("code",[v._v('<a target="_blank">')]),v._v("这种方式点击打开的新页面")]),v._v(" "),_("li",[_("code",[v._v("JS")]),v._v("代码打开的新页面（比如 "),_("code",[v._v("window.open")]),v._v(")")])])])])]),v._v(" "),_("h2",{attrs:{id:"解析文档"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解析文档"}},[v._v("#")]),v._v(" 解析文档")]),v._v(" "),_("p",[v._v("上述有提到渲染进程会解析内容，然后遇到请求网络的资源就会返回给浏览器进程进行加载，那么解析这个过程又是如何进行的呢？")]),v._v(" "),_("h3",{attrs:{id:"构建dom树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#构建dom树"}},[v._v("#")]),v._v(" 构建"),_("code",[v._v("DOM")]),v._v("树")]),v._v(" "),_("p",[v._v("渲染进程的主线程开始工作，解析"),_("code",[v._v("HTML")]),v._v("文本并转为"),_("code",[v._v("DOM")]),v._v("树")]),v._v(" "),_("h3",{attrs:{id:"子资源加载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#子资源加载"}},[v._v("#")]),v._v(" 子资源加载")]),v._v(" "),_("p",[v._v("当主线程解析遇到一些需要额外加载的资源时，如图片，"),_("code",[v._v("CSS")]),v._v("和"),_("code",[v._v("JavaScript")]),v._v("，为了提高请求速度，会向浏览器进程的网络线程发起请求。")]),v._v(" "),_("h3",{attrs:{id:"js阻塞解析过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js阻塞解析过程"}},[v._v("#")]),v._v(" JS阻塞解析过程")]),v._v(" "),_("p",[v._v("当"),_("code",[v._v("HTML")]),v._v("解析器遇到"),_("code",[v._v("script")]),v._v("标签时，会暂停"),_("code",[v._v("HTML")]),v._v("解析工作，转而去加载"),_("code",[v._v("Js")]),v._v("代码。因为这部分代码可能会影响文档结构。也会导致"),_("code",[v._v("CSSOM")]),v._v("也阻塞。")]),v._v(" "),_("h3",{attrs:{id:"样式计算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#样式计算"}},[v._v("#")]),v._v(" 样式计算")]),v._v(" "),_("p",[v._v("主线程解析计算完"),_("code",[v._v("CSS")]),v._v("产生"),_("code",[v._v("CSS")]),v._v("规则树，才会对文档节点赋予最终的样式。")]),v._v(" "),_("blockquote",[_("p",[v._v("处理过程：1.把"),_("code",[v._v("CSS")]),v._v("转换成浏览器能够理解的结构--"),_("code",[v._v("StyleSheets")]),v._v("，该结构同时具备了查询和修改功能。2.转换样式表中的属性值，使其标准化。3.计算出"),_("code",[v._v("DoM")]),v._v("树中的每个节点具体样式")])]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("CSS")]),v._v("加载会阻塞页面显示吗？")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("css")]),v._v("加载不会阻塞"),_("code",[v._v("DOM")]),v._v("树的解析")]),v._v(" "),_("li",[_("code",[v._v("css")]),v._v("加载会阻塞"),_("code",[v._v("DOM")]),v._v("树的渲染")]),v._v(" "),_("li",[_("code",[v._v("css")]),v._v("加载会阻塞后面"),_("code",[v._v("js")]),v._v("语句的执行")])])]),v._v(" "),_("li",[_("p",[v._v("下载"),_("code",[v._v("CSS")]),v._v("文件阻塞了，会阻塞"),_("code",[v._v("DOM")]),v._v("树的合成吗？会阻塞页面的显示吗？")])])]),v._v(" "),_("blockquote",[_("p",[v._v("不会阻塞"),_("code",[v._v("dom")]),v._v("树构建的，因为"),_("code",[v._v("HTML")]),v._v("转化为"),_("code",[v._v("dom")]),v._v("树的过程，发现文件请求会交给网络进程去请求对应文件，渲染进程继续解析"),_("code",[v._v("HTML")]),v._v("。\n会阻塞页面的显示，当计算样式的时候需要等待"),_("code",[v._v("css")]),v._v("文件的资源进行层叠样式，资源阻塞了，会进行等待，直到网络超时，"),_("code",[v._v("network")]),v._v("报出错误，渲染进程继续层叠样式计算。")])]),v._v(" "),_("h3",{attrs:{id:"布局-初次回流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#布局-初次回流"}},[v._v("#")]),v._v(" 布局（初次回流）")]),v._v(" "),_("blockquote",[_("p",[v._v("主线程遍历"),_("code",[v._v("DOM")]),v._v("并计算样式，创建一个具体横纵坐标以及盒子边界大小数据的布局树（"),_("code",[v._v("layout tree")]),v._v("）。布局树可能与"),_("code",[v._v("DOM")]),v._v("树相似，但它只包含和页面即将呈现的节点相关的信息。如果某个元素设置了"),_("code",[v._v("display: none")]),v._v("，虽然它会呈现在"),_("code",[v._v("DOM")]),v._v("树中但并不会包含于布局树当中；如果有一个伪类元素"),_("code",[v._v("p::before{ content: 'Hi!' }")]),v._v("， 那么它虽然不在"),_("code",[v._v("DOM")]),v._v("树中，但仍然会出现在布局树当中。")])]),v._v(" "),_("h3",{attrs:{id:"分层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分层"}},[v._v("#")]),v._v(" 分层")]),v._v(" "),_("p",[v._v("渲染引擎为特定的节点生成专用的图层，并生成一棵对应的图层树。拥有层叠上下文的元素会被单独提升为一层；需要剪裁的地方会被创建为图层（当超出容器内容被隐藏或出现滚动条均会被提升为单独层）")]),v._v(" "),_("h3",{attrs:{id:"图层绘制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图层绘制"}},[v._v("#")]),v._v(" 图层绘制")]),v._v(" "),_("p",[v._v("渲染引擎对图层树每个图层进行绘制。渲染引擎会把一个图层的绘制分成很多小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表。当图层的绘制列表准备好之后，主线程会把绘制列表交给合成线程。")]),v._v(" "),_("h3",{attrs:{id:"栅格化操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栅格化操作"}},[v._v("#")]),v._v(" 栅格化操作")]),v._v(" "),_("blockquote",[_("p",[v._v("将图块转换为位图，而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在里面执行的。")])]),v._v(" "),_("h3",{attrs:{id:"合成和显示"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#合成和显示"}},[v._v("#")]),v._v(" 合成和显示")]),v._v(" "),_("p",[v._v("一旦所有图块都栅格化，合成线程会生成一个绘制图块的命令，然后将该命令提交给浏览器进程。浏览器进程的"),_("code",[v._v("viz")]),v._v("组件接收合成线程发过来的命令。然后根据命令将其内容绘制到内存中，最后再将内存显示在屏幕上")]),v._v(" "),_("h2",{attrs:{id:"性能优化策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能优化策略"}},[v._v("#")]),v._v(" 性能优化策略")]),v._v(" "),_("blockquote",[_("p",[v._v("基于上面介绍的浏览器渲染原理，"),_("code",[v._v("DOM")]),v._v(" 和 "),_("code",[v._v("CSSOM")]),v._v(" 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("JS")]),v._v("优化： "),_("code",[v._v("<script>")]),v._v(" 标签加上 "),_("code",[v._v("defer")]),v._v("属性 和 "),_("code",[v._v("async")]),v._v("属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。"),_("code",[v._v("defer")]),v._v("属性：用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行，因此不会阻塞页面的渲染。"),_("code",[v._v("async")]),v._v("属性："),_("code",[v._v("HTML5")]),v._v("新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。")])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("p",[_("strong",[_("code",[v._v("defer")]),v._v("特性")]),v._v("\n换句话说：")]),v._v(" "),_("ul",[_("li",[v._v("具有 "),_("code",[v._v("defer")]),v._v(" 特性的脚本不会阻塞页面。")]),v._v(" "),_("li",[v._v("具有 "),_("code",[v._v("defer")]),v._v(" 特性的脚本总是要等到 "),_("code",[v._v("DOM")]),v._v(" 解析完毕，但在 "),_("code",[v._v("DOMContentLoaded")]),v._v(" 事件之前执行。")]),v._v(" "),_("li",[v._v("该特性仅适用于外部脚本，如果 "),_("code",[v._v("<script>")]),v._v(" 脚本没有 "),_("code",[v._v("src")]),v._v("，则会忽略 "),_("code",[v._v("defer")]),v._v(" 特性。")])]),v._v(" "),_("div",{staticClass:"language-js line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("script defer src"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"https://javascript.info/article/script-async-defer/long.js"')]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("/")]),v._v("script"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("script defer src"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"https://javascript.info/article/script-async-defer/small.js"')]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("/")]),v._v("script"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br")])]),_("blockquote",[_("p",[v._v("浏览器扫描页面寻找脚本，然后并行下载它们，以提高性能。因此，在上面的示例中，两个脚本是并行下载的。"),_("code",[v._v("small.js")]),v._v(" 可能会先下载完成。但是，"),_("code",[v._v("defer")]),v._v(" 特性除了告诉浏览器“不要阻塞页面”之外，还可以确保脚本执行的相对顺序。因此，即使"),_("code",[v._v("small.js")]),v._v(" 先加载完成，它也需要等到 "),_("code",[v._v("long.js")]),v._v(" 执行结束才会被执行。"),_("strong",[v._v("保证脚本的执行顺序，即按照它们在 "),_("code",[v._v("HTML")]),v._v(" 文件中出现的顺序执行。在页面渲染完成后，会按照它们在 "),_("code",[v._v("HTML")]),v._v(" 文件中出现的顺序执行脚本，因此适用于需要依赖其他脚本的脚本。")])])]),v._v(" "),_("p",[_("strong",[_("code",[v._v("async")]),v._v("特性")]),v._v(" "),_("code",[v._v("async")]),v._v(" 特性意味着脚本是完全独立的：")]),v._v(" "),_("ul",[_("li",[v._v("浏览器不会因 "),_("code",[v._v("async")]),v._v(" 脚本而阻塞（与 "),_("code",[v._v("defer")]),v._v(" 类似）。")]),v._v(" "),_("li",[v._v("其他脚本不会等待 "),_("code",[v._v("async")]),v._v(" 脚本加载完成，同样，"),_("code",[v._v("async")]),v._v(" 脚本也不会等待其他脚本。")]),v._v(" "),_("li",[_("code",[v._v("DOMContentLoaded")]),v._v(" 和异步脚本不会彼此等待：\n"),_("ul",[_("li",[_("code",[v._v("DOMContentLoaded")]),v._v(" 可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）")]),v._v(" "),_("li",[_("code",[v._v("DOMContentLoaded")]),v._v(" 也可能发生在异步脚本之后（如果异步脚本很短，或者是从 "),_("code",[v._v("HTTP")]),v._v(" 缓存中加载的）")])])])]),v._v(" "),_("p",[v._v("换句话说，"),_("code",[v._v("async")]),v._v(" 脚本会在后台加载，并在加载就绪时运行。"),_("code",[v._v("DOM")]),v._v(" 和其他脚本不会等待它们，它们也不会等待其它的东西。"),_("code",[v._v("async")]),v._v(" 脚本就是一个会在加载完成时执行的完全独立的脚本。"),_("strong",[v._v("异步加载脚本，但不保证脚本的执行顺序，即可能会出现多个脚本同时加载的情况。在脚本加载完成后，会立即执行脚本，不会阻塞页面的渲染，因此适用于不依赖其他脚本的单独脚本。如果有多个脚本需要依赖，可能会出现错误。")])]),v._v(" "),_("p",[_("strong",[v._v("动态添加脚本")]),v._v("\n当脚本被附加到文档 (*) 时，脚本就会立即开始加载。默认情况下，动态脚本的行为是“异步”的。\n也就是说：")]),v._v(" "),_("ul",[_("li",[v._v("它们不会等待任何东西，也没有什么东西会等它们。")]),v._v(" "),_("li",[v._v("先加载完成的脚本先执行（“加载优先”顺序）。")])]),v._v(" "),_("p",[v._v("如果我们显式地设置了 "),_("code",[v._v("script.async=false")]),v._v("，则可以改变这个规则。然后脚本将按照脚本在文档中的顺序执行，就像 "),_("code",[v._v("defer")]),v._v(" 那样。")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("CSS")]),v._v("优化："),_("code",[v._v("<link>")]),v._v(" 标签的 "),_("code",[v._v("rel")]),v._v("属性 中的属性值设置为 "),_("code",[v._v("preload")])])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("preload")]),v._v(" 是一种浏览器预加载技术，用于在页面渲染之前，提前加载一些资源（例如 "),_("code",[v._v("JavaScript")]),v._v("、"),_("code",[v._v("CSS")]),v._v("、字体等），以加速页面加载速度。"),_("code",[v._v("preload")]),v._v(" 可以通过 "),_("code",[v._v("<link>")]),v._v(" 标签或 "),_("code",[v._v("HTTP")]),v._v(" 头来实现，具体实现方式如下：")])]),v._v(" "),_("div",{staticClass:"language-js line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("link rel"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"preload"')]),v._v(" href"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"style.css"')]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("as")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"style"')]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v("\n\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v('// 通过HTTP头实现：在服务器端设置HTTP头，以指定要预加载的资源。例如，以下代码可以预加载名为"script.js"的JavaScript文件：')]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token literal-property property"}},[v._v("Link")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("script"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("js"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v(" rel"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v("preload"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("as")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v("script\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br")])]),_("ul",[_("li",[_("code",[v._v("preconnect")]),v._v(" 则是一种浏览器预连接技术，用于在页面加载之前，预先建立与一些服务器的 "),_("code",[v._v("TCP")]),v._v(" 连接，以加速资源的请求和响应速度。"),_("code",[v._v("preconnect")]),v._v(" 可以通过"),_("code",[v._v("<link>")]),v._v(" 标签或 "),_("code",[v._v("HTTP")]),v._v(" 头来实现，具体实现方式如下：")])]),v._v(" "),_("div",{staticClass:"language-js line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("link rel"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"preconnect"')]),v._v(" href"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"https://example.com"')]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v("\n\n"),_("span",{pre:!0,attrs:{class:"token literal-property property"}},[v._v("Link")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("https"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("/")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("/")]),v._v("example"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("com"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v(" rel"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v("preconnect\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br")])]),_("ul",[_("li",[_("code",[v._v("prefetch")]),v._v(" 用于在浏览器的空闲时间请求资源")])])]),v._v(" "),_("h2",{attrs:{id:"渲染过程总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程总结"}},[v._v("#")]),v._v(" 渲染过程总结")]),v._v(" "),_("blockquote",[_("p",[v._v("当浏览器获取"),_("code",[v._v("HTML")]),v._v("文件后，会自上而下加载并在加载过程中进行解析和渲染；加载就是获取资源的过程；如果在加载过程中遇到外部的"),_("code",[v._v("css")]),v._v("文件和图片，浏览器会另外发送一个请求，去获取"),_("code",[v._v("css")]),v._v("文件和图片，这个请求是异步的，并不会影响"),_("code",[v._v("HTML")]),v._v("文件的加载；但如果遇到"),_("code",[v._v("JavaScript")]),v._v("文件，"),_("code",[v._v("HTML")]),v._v("文件会挂起渲染的进程，等待"),_("code",[v._v("JavaScript")]),v._v("文件加载完毕后，再继续进行渲染。")])]),v._v(" "),_("ol",[_("li",[v._v("浏览器解析"),_("code",[v._v("HTML")]),v._v("，"),_("code",[v._v("CSS")]),v._v("和"),_("code",[v._v("JavaScript")]),v._v("脚本。等脚本加载后，通过 "),_("code",[v._v("DOM API")]),v._v(" 和 "),_("code",[v._v("CSSOM API")]),v._v(" 来操作 "),_("code",[v._v("DOM Tree")]),v._v(" 和 "),_("code",[v._v("CSS Rule Tree")]),v._v("。")]),v._v(" "),_("li",[v._v("解析完成后，浏览器引擎通过两种树结构来构造渲染树。"),_("strong",[v._v("渲染树只包含可见节点")])])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("ul",[_("li",[v._v("构建渲染树的过程，浏览器还做了一些关键的小动作：\n"),_("ul",[_("li",[v._v("从"),_("code",[v._v("DOM")]),v._v("树的根节点开始遍历，筛选出所有可见的节点；")]),v._v(" "),_("li",[v._v("仅针对可见节点，为其匹配"),_("code",[v._v("CSSOM")]),v._v("中的"),_("code",[v._v("CSS")]),v._v("规则；")]),v._v(" "),_("li",[v._v("发射可见节点，连同其内容和计算样式。")])])])])]),v._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[_("code",[v._v("Layout")]),v._v("回流：根据生成的渲染树，进行回流，得到节点的几何信息。")]),v._v(" "),_("li",[v._v("重绘：根据渲染树以及回流得到的几何信息，得到节点的绝对像素")]),v._v(" "),_("li",[v._v("将像素发给"),_("code",[v._v("GPU")]),v._v("进程，展示在页面上。")])]),v._v(" "),_("h2",{attrs:{id:"回流-reflow-也叫重排"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#回流-reflow-也叫重排"}},[v._v("#")]),v._v(" 回流("),_("code",[v._v("Reflow")]),v._v("，也叫重排)")]),v._v(" "),_("blockquote",[_("p",[v._v("是指当页面布局和几何属性改变时触发的浏览器行为，浏览器会重新计算并绘制元素的布局和几何属性。重排会导致整个页面的布局发生改变，非常消耗性能，所以要尽量避免频繁地进行页面布局的改变。"),_("strong",[v._v("回流一定会导致重绘")])])]),v._v(" "),_("ul",[_("li",[v._v("什么情况会回流（为了求一个即时性和准确性）\n"),_("ul",[_("li",[v._v("添加或者删除可见的"),_("code",[v._v("DOM")]),v._v("元素")]),v._v(" "),_("li",[v._v("元素的位置发生变化")]),v._v(" "),_("li",[v._v("元素的尺寸发生变化")]),v._v(" "),_("li",[v._v("内容发生变化")]),v._v(" "),_("li",[_("strong",[v._v("页面一开始的时候")])]),v._v(" "),_("li",[v._v("浏览器的窗口尺寸变化")]),v._v(" "),_("li",[v._v("设置"),_("code",[v._v("style")]),v._v("属性的值")]),v._v(" "),_("li",[v._v("计算"),_("code",[v._v("offsetWidth/offsetHeight/clientWidth/等")]),v._v("的属性")]),v._v(" "),_("li",[v._v("调用"),_("code",[v._v("getComputedStyle/currentStyle")])])])])]),v._v(" "),_("h2",{attrs:{id:"重绘-repaint"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重绘-repaint"}},[v._v("#")]),v._v(" 重绘("),_("code",[v._v("Repaint")]),v._v(")")]),v._v(" "),_("blockquote",[_("p",[v._v("是指当元素的样式发生改变，但不影响元素的布局和几何属性时触发的浏览器行为。在这种情况下，浏览器只需要重新绘制元素的外观而不需要重新计算布局和几何属性，因此比重排的代价小得多。重绘的代价比重排小，但如果频繁进行大量的重绘操作，也会对性能产生影响。"),_("strong",[v._v("重绘不一定会引起回流")])])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("ul",[_("li",[v._v("并且很多人不知道的是，重绘和回流其实也和 "),_("code",[v._v("Eventloop")]),v._v(" 有关。\n"),_("ul",[_("li",[v._v("当 "),_("code",[v._v("Eventloop")]),v._v(" 执行完 "),_("code",[v._v("Microtasks")]),v._v(" 后，会判断 "),_("code",[v._v("document")]),v._v(" 是否需要更新，因为浏览器是 "),_("code",[v._v("60Hz")]),v._v(" 的刷新率，每 "),_("code",[v._v("16.6ms")]),v._v(" 才会更新一次。")]),v._v(" "),_("li",[v._v("然后判断是否有 "),_("code",[v._v("resize")]),v._v(" 或者 "),_("code",[v._v("scroll")]),v._v(" 事件，有的话会去触发事件，所以 "),_("code",[v._v("resize")]),v._v(" 和 "),_("code",[v._v("scroll")]),v._v(" 事件也是至少 "),_("code",[v._v("16ms")]),v._v(" 才会触发一次，并且自带节流功能。")]),v._v(" "),_("li",[v._v("判断是否触发了 "),_("code",[v._v("media query")])]),v._v(" "),_("li",[v._v("更新动画并且发送事件")]),v._v(" "),_("li",[v._v("判断是否有全屏操作事件")]),v._v(" "),_("li",[v._v("执行 "),_("code",[v._v("requestAnimationFrame")]),v._v(" 回调")]),v._v(" "),_("li",[v._v("执行 "),_("code",[v._v("IntersectionObserver")]),v._v(" 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好")]),v._v(" "),_("li",[v._v("更新界面")]),v._v(" "),_("li",[v._v("以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 "),_("code",[v._v("requestIdleCallback")]),v._v(" 回调。")])])])])]),v._v(" "),_("h2",{attrs:{id:"减少重绘与回流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#减少重绘与回流"}},[v._v("#")]),v._v(" 减少重绘与回流")]),v._v(" "),_("ul",[_("li",[v._v("合并多次对"),_("code",[v._v("DOM")]),v._v("和样式的修改，然后一次性处理掉")]),v._v(" "),_("li",[v._v("使用"),_("code",[v._v("transform")]),v._v("替代"),_("code",[v._v("top")]),v._v("（"),_("code",[v._v("css3")]),v._v("的硬件加速，不会引起重绘回流。还有"),_("code",[v._v("opacity")]),v._v("，"),_("code",[v._v("filters")]),v._v(","),_("code",[v._v("Will-change")]),v._v("这些属性）")])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("opacity")]),v._v("单词意思为透明度，直观视觉效果就是颜色变淡了，但最终显示的颜色其实仍然可以用"),_("code",[v._v("RGB")]),v._v("三个通道来表示，从数值运算的角度来看，它实际上表示了它采用一般混合策略和其他颜色进行混合时的比例。"),_("code",[v._v("显示颜色 = 合入色 x opacity + 底色 x (1 - opacity)")])])]),v._v(" "),_("ol",[_("li",[_("p",[_("code",[v._v("opacity")]),v._v("这个属性本身就是用在重叠部分颜色处理的过程中使用的，对于分层的图原来说就可以看作是与图层内容无关的系数，因为合成过程中当前层中所有像素都需要经历上面的颜色混合公式，所以"),_("code",[v._v("opacity")]),v._v("的动画过程既不会影响布局，也不需要重绘。这样图层中保存的"),_("code",[v._v("RGB")]),v._v("像素数据的缓存在动画过程中也就不需要更新了，如果不使用"),_("code",[v._v("opacity")]),v._v("属性的话，每一帧对于变化部分都需要手动重计算"),_("code",[v._v("RGB")]),v._v("颜色值（这也就相当于是重绘了），因为这些区域的像素颜色一直都在变化，缓存也就没有意义。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("transform")]),v._v("在动画过程中也不需要改变缓存的记录，而在图层合成时遍历当前层的点然后用矩阵"),_("code",[v._v("matrix")]),v._v("计算出对应的新坐标点就可以了，它也可以视作一种与图层内容无关的变换，图层中的元素首次生成的位图信息缓存可以被反复使用。"),_("strong",[v._v("比如一段平移动画，如果使用绝对定位+改变"),_("code",[v._v("left")]),v._v("值的方式来实现，就需要不断计算动画元素的布局并更新它的像素信息，但如果使用"),_("code",[v._v("translate")]),v._v("来实现，动画元素在文档流中的位置并不需要改变，无论后续平移到多远，都可以使用位图缓存中保存的初始位置信息，再加上变换矩阵的影响在层合并时计算出来，同样既不影响布局，也不需要重绘，这就是它高性能的原因。")])])])]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("transform")]),v._v("动画由"),_("code",[v._v("GPU")]),v._v("控制，支持硬件加速")])])]),v._v(" "),_("ul",[_("li",[v._v("使用"),_("code",[v._v("visibility")]),v._v("替换"),_("code",[v._v("display: none")]),v._v("，前者只会引起重绘，后者会引起回流（布局改变了）")]),v._v(" "),_("li",[v._v("不要把节点的属性值放在一个循环里当成循环的变量")]),v._v(" "),_("li",[v._v("不要使用"),_("code",[v._v("table")]),v._v("布局")]),v._v(" "),_("li",[v._v("动画速度越快，回流次数越多，可以使用"),_("code",[v._v("reuqestAnimationFrame")])]),v._v(" "),_("li",[_("code",[v._v("CSS")]),v._v("避免节点层级过多")]),v._v(" "),_("li",[v._v("将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点\n"),_("ul",[_("li",[v._v("使用"),_("code",[v._v("will-change")]),v._v("生成新图层")]),v._v(" "),_("li",[_("code",[v._v("video/iframe")]),v._v("标签")])])]),v._v(" "),_("li",[v._v("对"),_("code",[v._v("DOM")]),v._v("一系列修改时，我们可以使元素脱离文档流，对其进行多次修改，然后将元素带回到文档中。因为这个时候修改，元素已经不在渲染树中。脱离文档流方式：\n"),_("ul",[_("li",[v._v("隐藏元素，应用修改，重新显式")]),v._v(" "),_("li",[v._v("使用文档片段("),_("code",[v._v("document fragment)")]),v._v("在当前"),_("code",[v._v("DOM")]),v._v("之外构建一个子树，再把它拷贝回文档。")]),v._v(" "),_("li",[v._v("将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。")])])])]),v._v(" "),_("h2",{attrs:{id:"为什么操作dom慢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么操作dom慢"}},[v._v("#")]),v._v(" 为什么操作DOM慢")]),v._v(" "),_("blockquote",[_("p",[v._v("因为 "),_("code",[v._v("DOM")]),v._v(" 是属于渲染引擎中的东西，而 "),_("code",[v._v("JS")]),v._v(" 又是 "),_("code",[v._v("JS")]),v._v(" 引擎中的东西。当我们通过 "),_("code",[v._v("JS")]),v._v(" 操作 "),_("code",[v._v("DOM")]),v._v(" 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 "),_("code",[v._v("DOM")]),v._v(" 次数一多，也就等同于一直在进行线程之间的通信，并且操作 "),_("code",[v._v("DOM")]),v._v(" 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);