(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{387:function(v,_,o){"use strict";o.r(_);var e=o(10),t=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"https的工作原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https的工作原理"}},[v._v("#")]),v._v(" https的工作原理")]),v._v(" "),_("p",[_("code",[v._v("HTTPS")]),v._v("并非是应用层一个新的协议，通常 "),_("code",[v._v("HTTP")]),v._v(" 直接和 "),_("code",[v._v("TCP")]),v._v(" 通信，"),_("code",[v._v("HTTPS")]),v._v("则先和安全层（"),_("code",[v._v("SSL/TLS")]),v._v("）通信，然后安全层再和 "),_("code",[v._v("TCP")]),v._v(" 层通信。")]),v._v(" "),_("p",[_("strong",[_("code",[v._v("HTTPS")]),v._v(" 在 "),_("code",[v._v("TCP")]),v._v(" 三次握⼿之后，还需进⾏ "),_("code",[v._v("SSL/TLS")]),v._v(" 的握⼿过程，才可进⼊加密报⽂传输。")])]),v._v(" "),_("p",[_("code",[v._v("SSL/TLS")]),v._v("是怎么解决"),_("code",[v._v("HTTP")]),v._v("存在的问题的：")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("HTTP")]),v._v("存在的问题")]),v._v(" "),_("ul",[_("li",[v._v("窃听风险：通信使用明文（不加密），内容可能会被窃听（第三方可能获取通信内容）")]),v._v(" "),_("li",[v._v("冒充风险：不验证通信方的身份，因此有可能遭遇伪装")]),v._v(" "),_("li",[v._v("篡改风险：无法证明报文的完整性，所以有可能已经遭遇篡改")])])]),v._v(" "),_("li",[_("p",[_("code",[v._v("SSL/TLS")]),v._v("解决：")]),v._v(" "),_("ul",[_("li",[v._v("混合加密的⽅式实现信息的机密性，第三方无法窃听")]),v._v(" "),_("li",[v._v("将服务器公钥放⼊到数字证书中，解决了冒充的⻛险。")]),v._v(" "),_("li",[v._v("摘要算法的⽅式来实现完整性，它能够为数据⽣成独⼀⽆⼆的「指纹」，指纹⽤于校验数据的完整性，解决了篡改的⻛险。")])]),v._v(" "),_("blockquote",[_("p",[v._v("客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。")])])])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("p",[v._v("运输层安全协议。现在广泛使用两个协议：")]),v._v(" "),_("ul",[_("li",[v._v("安全套接字层"),_("code",[v._v("SSL")])]),v._v(" "),_("li",[v._v("运输层安全"),_("code",[v._v("TLS")])])]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("SSL")]),v._v("协议作用在端系统应用层的"),_("code",[v._v("HTTP")]),v._v("和运输层之间，在"),_("code",[v._v("TCP")]),v._v("之上建立一个安全通道，为通过"),_("code",[v._v("TCP")]),v._v("传输的应用层数据提供安全保障。"),_("code",[v._v("TLS")]),v._v("是在"),_("code",[v._v("SSL 3.0")]),v._v("的基础上设计的，为所有基于"),_("code",[v._v("TCP")]),v._v("的网络应用提供安全数据传输服务。"),_("code",[v._v("SSL/TLS")]),v._v("处于应用层和传输层之间。使用"),_("code",[v._v("https")]),v._v("时，在发送方"),_("code",[v._v("SSL")]),v._v("接收应用层的数据，对数据进行加密，然后把加了密的数据送往"),_("code",[v._v("TCP")]),v._v("套接字。在接收方，"),_("code",[v._v("SSL")]),v._v("从"),_("code",[v._v("TCP")]),v._v("套接字读取数据，解密后把数据交给应用层。")])]),v._v(" "),_("p",[_("code",[v._v("SSL")]),v._v("提供的安全服务可以归纳为三种：")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("SSL")]),v._v("服务器鉴别，允许用户证实服务器的身份。支持"),_("code",[v._v("SSL")]),v._v("的客户端通过验证来自服务器的证书，来鉴别服务器的真实身份并获得服务器的公钥")]),v._v(" "),_("li",[_("code",[v._v("SSL")]),v._v("客户鉴别，"),_("code",[v._v("SSL")]),v._v("的可选安全服务，允许服务器证实客户的身份")]),v._v(" "),_("li",[v._v("加密的"),_("code",[v._v("SSL")]),v._v("会话")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("SSL/TLS")]),v._v("协议基本流程：\n"),_("ul",[_("li",[v._v("客户端向服务器所要并验证服务器的公钥")]),v._v(" "),_("li",[v._v("双方协商生成会话密钥")]),v._v(" "),_("li",[v._v("双方采用会话密钥进行加密通信")])])])]),v._v(" "),_("blockquote",[_("p",[v._v("前两步是"),_("code",[v._v("SSL/TLS")]),v._v("的建立过程，也就是握手阶段")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("SSL/TLS")]),v._v("协议建立的详细流程：\n"),_("ol",[_("li",[_("code",[v._v("ClientHello")])])]),v._v(" "),_("blockquote",[_("p",[v._v("首先由客户端向服务器发起加密通信请求，也就是"),_("code",[v._v("ClientHello")]),v._v("请求。在这一步，客户端主要向服务器发送以下信息：")])]),v._v(" "),_("ul",[_("li",[v._v("客户端支持的"),_("code",[v._v("SSL/TLS")]),v._v("协议版本，如"),_("code",[v._v("TLS 1.2")]),v._v("版本")]),v._v(" "),_("li",[v._v("客户端生产的随机数（"),_("code",[v._v("Client Random")]),v._v("）后面用于生产会话密钥。")]),v._v(" "),_("li",[v._v("客户端支持的密码套件列表，如"),_("code",[v._v("RSA")]),v._v("加密算法。")])]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("code",[v._v("ServerHello")])])]),v._v(" "),_("blockquote",[_("p",[v._v("服务器收到客户端请求后，向客户端发出响应，也就是"),_("code",[v._v("ServerHello")]),v._v("。服务器回应的内容有如以下内容：")])]),v._v(" "),_("ul",[_("li",[v._v("确认"),_("code",[v._v("SSL/TLS")]),v._v("协议版本，如果浏览器不支持就关闭加密通信。")]),v._v(" "),_("li",[v._v("服务器生产的随机数（"),_("code",[v._v("Server Random")]),v._v("）后面用于生产会话密钥")]),v._v(" "),_("li",[v._v("确认的密码套件列表，如"),_("code",[v._v("RSA")]),v._v("加密算法。")]),v._v(" "),_("li",[v._v("服务器的数字证书。")])]),v._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[v._v("客户端回应")])]),v._v(" "),_("blockquote",[_("p",[v._v("客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使⽤它加密报⽂，向服务器发送如下信息：")])]),v._v(" "),_("ul",[_("li",[v._v("一个随机数（"),_("code",[v._v("pre-master key")]),v._v("）该随机数会被服务器公钥加密。")]),v._v(" "),_("li",[v._v("加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。")]),v._v(" "),_("li",[v._v("客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘要，⽤来供服务端校验")])]),v._v(" "),_("blockquote",[_("p",[v._v("上⾯第⼀项的随机数是整个握⼿阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就⽤双⽅协商的加密算法，各⾃⽣成本次通信的「会话秘钥」。")])]),v._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[v._v("服务器的最后回应")])]),v._v(" "),_("blockquote",[_("p",[v._v("服务器收到客户端的第三个随机数（ "),_("code",[v._v("pre-master key")]),v._v(" ）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发⽣最后的信息：")])]),v._v(" "),_("ul",[_("li",[v._v("加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。")]),v._v(" "),_("li",[v._v("服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘要，⽤来供客户端校验。")])])])]),v._v(" "),_("blockquote",[_("p",[v._v("至此整个"),_("code",[v._v("SSL/TLS")]),v._v("握手阶段全部结束，接下来客户端和服务器进入加密通信，就完全是使⽤普通的 "),_("code",[v._v("HTTP")]),v._v(" 协议，只不过⽤「会话秘钥」加密内容。")])])]),v._v(" "),_("h2",{attrs:{id:"加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#加密"}},[v._v("#")]),v._v(" 加密")]),v._v(" "),_("h3",{attrs:{id:"对此加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对此加密"}},[v._v("#")]),v._v(" 对此加密")]),v._v(" "),_("blockquote",[_("p",[v._v("在每次数据传输之前，小服会先传输给小客一把密钥，然后小服在之后给小客发消息的过程中，会用这把密钥对这些消息进行加密。小客在收到这些消息后，会用之前小服给的那把密钥对这些消息进行解密，这样，小客就能得到密文里面真正的数据了。如果小客要给小服发消息，也同样用这把密钥来对消息进行加密，小服收到后也用这把密钥进行解密。")])]),v._v(" "),_("p",[v._v("加密和解密用同一个密钥的方式称为共享密钥加密，也被叫做对称密钥加密。")]),v._v(" "),_("p",[_("img",{attrs:{src:"/dovis-blog/other/25.jpg",alt:"img"}})]),v._v(" "),_("ul",[_("li",[v._v("浏览器发送给服务端 "),_("code",[v._v("client_random")]),v._v(" 和一系列加密方法")]),v._v(" "),_("li",[v._v("服务端发送给浏览器 "),_("code",[v._v("server_random")]),v._v(" 和加密方法")])]),v._v(" "),_("blockquote",[_("p",[v._v("现有浏览器和服务器有了三个相同的凭证："),_("code",[v._v("client_random")]),v._v("、"),_("code",[v._v("server_random")]),v._v("和加密方法 用加密方法把"),_("code",[v._v("client_random")]),v._v("、"),_("code",[v._v("server_random")]),v._v(" 两个随机数混合起来，生成秘钥，这个密钥就是浏览器和服务端通信的暗号。\n存在的问题：第三方可以在中间获取到"),_("code",[v._v("client_random")]),v._v("、"),_("code",[v._v("server_random")]),v._v("和加密方法，由于这个加密方法同时可以解密，所以中间人可以成功对暗号进行解密，拿到数据，很容易就将这种加密方式破解了。")])]),v._v(" "),_("h3",{attrs:{id:"非对称加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密"}},[v._v("#")]),v._v(" 非对称加密")]),v._v(" "),_("blockquote",[_("p",[v._v("需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密的时候，另一个则用作解密。使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；")])]),v._v(" "),_("p",[_("img",{attrs:{src:"/dovis-blog/other/26.jpg",alt:"img"}})]),v._v(" "),_("ul",[_("li",[v._v("浏览器发送给服务器端一系列加密方法")]),v._v(" "),_("li",[v._v("服务端发送给浏览器加密方法和公钥")])]),v._v(" "),_("blockquote",[_("p",[v._v("之后浏览器通过公钥将数据加密传输给服务端，服务端收到数据使用私钥进行解密。服务端给浏览器发送数据，则使用私钥进行加密，浏览器收到服务端发送过来的数据，使用公钥进行解密。")])]),v._v(" "),_("p",[v._v("存在的问题：")]),v._v(" "),_("ol",[_("li",[v._v("非对称加密效率太低：会严重影响解密的速度，进而影响到用户打开页面的速度。")]),v._v(" "),_("li",[v._v("无法保证服务器发送给浏览器的数据安全，服务器的数据只能用私钥进行加密（因为如果它用公钥那么浏览器也没法解密），中间人一旦拿到公钥，就可以对服务端传来的数据进行解密了，就这样又被破解了。")])]),v._v(" "),_("h3",{attrs:{id:"https使用两种加密结合"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https使用两种加密结合"}},[v._v("#")]),v._v(" HTTPS使用两种加密结合")]),v._v(" "),_("p",[v._v("传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密传输。"),_("strong",[_("code",[v._v("HTTPS")]),v._v(" 协议之所以是安全的是因为 "),_("code",[v._v("HTTPS")]),v._v(" 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现。但其实，"),_("code",[v._v("HTTPS")]),v._v(" 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"/dovis-blog/other/27.jpg",alt:"img"}})]),v._v(" "),_("ul",[_("li",[v._v("浏览器向服务器发送"),_("code",[v._v("client_random")]),v._v("和加密方法列表")]),v._v(" "),_("li",[v._v("服务器收到，返回"),_("code",[v._v("server_random")]),v._v("，加密方法和公钥")]),v._v(" "),_("li",[v._v("浏览器接收，接着生成另一个随机数"),_("code",[v._v("pre_master")]),v._v("，并且公钥加密，传给服务器。")]),v._v(" "),_("li",[v._v("服务器用私钥解密这个被加密后的"),_("code",[v._v("pre_master")])])]),v._v(" "),_("blockquote",[_("p",[v._v("到此为止，服务器和浏览器就有了相同的  "),_("code",[v._v("client_random")]),v._v("、"),_("code",[v._v("server_random")]),v._v(" 和 "),_("code",[v._v("pre_master")]),v._v(", 然后服务器和浏览器会使用这三组随机数生成对称秘钥。有了对称秘钥之后，双方就可以使用对称加密的方式来传输数据了。")])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("ul",[_("li",[v._v("采用混合加密的原因")])]),v._v(" "),_("ol",[_("li",[v._v("对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。")]),v._v(" "),_("li",[v._v("⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢")])])]),v._v(" "),_("h2",{attrs:{id:"ca-数字证书-需要做什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ca-数字证书-需要做什么"}},[v._v("#")]),v._v(" CA（数字证书）需要做什么")]),v._v(" "),_("ul",[_("li",[v._v("证书包含的信息\n"),_("ul",[_("li",[v._v("颁发机构信息")]),v._v(" "),_("li",[v._v("公钥")]),v._v(" "),_("li",[v._v("公司信息")]),v._v(" "),_("li",[v._v("域名")]),v._v(" "),_("li",[v._v("有效期")]),v._v(" "),_("li",[v._v("指纹")]),v._v(" "),_("li",[v._v("...")])])])]),v._v(" "),_("p",[v._v("我们在申请一个 "),_("code",[v._v("https")]),v._v(" 证书的时候，要在市场上选择一家 "),_("code",[v._v("CA")]),v._v(" 来给你签发证书，那么 "),_("code",[v._v("CA")]),v._v(" 的工作是什么呢？")]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("CA")]),v._v(" 要验证这个域名真的是你的：通常就是通过 "),_("code",[v._v("DNS")]),v._v(" 记录或者就是你在指定 "),_("code",[v._v("URI")]),v._v(" 下放置一个特殊文件，让 "),_("code",[v._v("CA")]),v._v(" 可以在外网环境下访问到它。")])]),v._v(" "),_("p",[v._v("对于浏览器来说，数字证书有两个作用：")]),v._v(" "),_("ul",[_("li",[v._v("通过数字证书向浏览器证明服务器的身份")]),v._v(" "),_("li",[v._v("数字证书里面包含了服务器公钥")])]),v._v(" "),_("p",[v._v("相比于不含数字证书的"),_("code",[v._v("HTTPS")]),v._v("请求流程，主要以下两个改动：")]),v._v(" "),_("ul",[_("li",[v._v("服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含数字证书中的；")]),v._v(" "),_("li",[v._v("在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后序流程。")])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("ol",[_("li",[v._v("服务端把自己的公钥注册到"),_("code",[v._v("CA")]),v._v("上")]),v._v(" "),_("li",[_("code",[v._v("CA")]),v._v("用自己的私钥将服务器的公钥数字签名并颁发数字证书")]),v._v(" "),_("li",[v._v("客户端拿到服务器的数字证书后，使用"),_("code",[v._v("CA")]),v._v("的公钥确认服务器的数字证书的真实性。")]),v._v(" "),_("li",[v._v("从数字证书获取服务器公钥后，使用它对报文加密后发送。")]),v._v(" "),_("li",[v._v("服务器用私钥对报文进行解密")])])]),v._v(" "),_("h2",{attrs:{id:"https验证过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https验证过程"}},[v._v("#")]),v._v(" HTTPS验证过程")]),v._v(" "),_("p",[_("img",{attrs:{src:"/dovis-blog/other/28.jpg",alt:"img"}})]),v._v(" "),_("ol",[_("li",[v._v("证书验证阶段")])]),v._v(" "),_("ul",[_("li",[v._v("浏览器发起"),_("code",[v._v("HTTPS")]),v._v("请求")]),v._v(" "),_("li",[v._v("服务端返回"),_("code",[v._v("HTTPS")]),v._v("证书")]),v._v(" "),_("li",[v._v("客户端验证证书是否合法，如果不合法则提示告警。")])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("ul",[_("li",[v._v("浏览器如何验证证书的合法性？")])]),v._v(" "),_("blockquote",[_("p",[v._v("浏览器发起 "),_("code",[v._v("HTTPS")]),v._v(" 请求时，服务器会返回网站的 "),_("code",[v._v("SSL")]),v._v(" 证书，浏览器需要对证书做以下验证：")])]),v._v(" "),_("ol",[_("li",[v._v("验证域名，有效期等信息是否正确。证书上都包含这些信息，比较容易完成验证。")]),v._v(" "),_("li",[v._v("判断证书是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统，浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书来完成源验证；")]),v._v(" "),_("li",[v._v("判断证书是否被篡改。需要和"),_("code",[v._v("CA")]),v._v("服务器进行校验。")]),v._v(" "),_("li",[v._v("判断证书是否已吊销。通过"),_("code",[v._v("CRL")]),v._v("和"),_("code",[v._v("OCSP")]),v._v("实现，其中"),_("code",[v._v("OCSP")]),v._v("可以用于第三步以减少和"),_("code",[v._v("CA")]),v._v("服务器的交互，提高验证效率。")])]),v._v(" "),_("ul",[_("li",[v._v("证书是公开的，如果要发起中间人攻击，我在官网上下载一份证书作为我的服务器证书，那客户端肯定会认同这个证书是合法的，如何避免这种证书冒用的情况？")])]),v._v(" "),_("blockquote",[_("p",[v._v("其实这就是非加密对称中公私钥的用处，虽然中间人可以得到证书，但私钥是无法获取的，一份公钥是不可能推算出其对应的私钥，中间人即使拿到证书也无法伪装成合法服务端，因为无法对客户端传入的加密数据进行解密。")])])]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[v._v("数据传输阶段")])]),v._v(" "),_("ul",[_("li",[v._v("当证书验证合法后，在本地生成用于改造对称加密算法的随机数")]),v._v(" "),_("li",[v._v("通过公钥加密随机数，并把加密后的随机数传输到服务端")]),v._v(" "),_("li",[v._v("服务端通过私钥对随机数进行解密")]),v._v(" "),_("li",[v._v("服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输。")])]),v._v(" "),_("blockquote",[_("p",[v._v("验证通过后本地生成用于改造对称加密算法的随机数，通过证书中的公钥对随机数进行加密传输到服务端，服务端接收后通过私钥解密得到随机数，之后的数据交互通过对称加密算法进行加解密。")])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("ul",[_("li",[v._v("为什么数据传输是用对称加密")])]),v._v(" "),_("blockquote",[_("p",[v._v("首先，非对称加密的加解密效率是非常低的，而 "),_("code",[v._v("http")]),v._v(" 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的；另外，在 "),_("code",[v._v("HTTPS")]),v._v(" 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 "),_("code",[v._v("HTTPS")]),v._v(" 中内容传输加密采取的是对称加密，而不是非对称加密。")])]),v._v(" "),_("ul",[_("li",[v._v("为什么需要CA认证机构颁发证书")])]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("HTTP")]),v._v(" 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而 "),_("code",[v._v("HTTPS")]),v._v(" 协议主要解决的便是网络传输的安全性问题。首先我们假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的 “中间人攻击” 问题。")])])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("ul",[_("li",[v._v("引入证书之后的一个流程\n"),_("ul",[_("li",[v._v("服务端把自己的公钥"),_("code",[v._v("key1")]),v._v("发给证书颁发机构，向证书颁发机构申请证书。")]),v._v(" "),_("li",[v._v("证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密"),_("code",[v._v("key1")]),v._v("，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构来私钥加密。证书制作完成后，机构把证书发送给服务端。")]),v._v(" "),_("li",[v._v("当客户端向服务端请求通信的时候，服务端不再直接返回自己的公钥，而是把自己申请的证书返回给客户端")]),v._v(" "),_("li",[v._v("客户端收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是"),_("strong",[v._v("各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥")]),v._v("。所以客户端只需要知道是哪个机构颁发的证书，就可以从本地找到对应的机构公钥，解密出证书签名。接下来客户端按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。验证成功后，客户端就可以放心地再次利用机构公钥，解密出服务端的公钥"),_("code",[v._v("key1")])]),v._v(" "),_("li",[v._v("客户端生成自己的对称加密密钥"),_("code",[v._v("key2")]),v._v("，并且用服务端公钥加密然后发送给服务端。")]),v._v(" "),_("li",[v._v("最后服务器端用自己的私钥解开加密，得到对称加密密钥"),_("code",[v._v("key2")]),v._v("。于是两端用"),_("code",[v._v("key2")]),v._v("进行对称加密通信。")])])])]),v._v(" "),_("p",[_("strong",[v._v("中间人通过发一个伪造的证书也是没用的，因为证书的签名是由服务端等信息生成的，并且经过机构私钥加密，中间人也无法篡改。所以，发给客户端的假证书也是无法验证通过的")])])]),v._v(" "),_("h2",{attrs:{id:"https连接建立过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https连接建立过程"}},[v._v("#")]),v._v(" "),_("code",[v._v("HTTPS")]),v._v("连接建立过程")]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("HTTPS")]),v._v(" 连接建立过程和 "),_("code",[v._v("HTTP")]),v._v(" 差不多，区别在于 "),_("code",[v._v("HTTP")]),v._v("（默认端口 "),_("code",[v._v("80")]),v._v("） 请求只要在 "),_("code",[v._v("TCP")]),v._v(" 连接建立后就可以发起，而 "),_("code",[v._v("HTTPS")]),v._v("（默认端口 "),_("code",[v._v("443")]),v._v("） 在 "),_("code",[v._v("TCP")]),v._v(" 连接建立后，还需要经历 "),_("code",[v._v("SSL")]),v._v(" 协议握手，成功后才能发起请求。")])]),v._v(" "),_("p",[v._v("简化版"),_("code",[v._v("SSL")]),v._v("握手")]),v._v(" "),_("h2",{attrs:{id:"https协议的工作原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https协议的工作原理"}},[v._v("#")]),v._v(" https协议的工作原理")]),v._v(" "),_("ul",[_("li",[v._v("客户使用"),_("code",[v._v("https url")]),v._v("访问服务器，则要求"),_("code",[v._v("web")]),v._v(" 服务器建立"),_("code",[v._v("ssl")]),v._v("链接。")]),v._v(" "),_("li",[_("code",[v._v("web")]),v._v("服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。")]),v._v(" "),_("li",[v._v("客户端和"),_("code",[v._v("web")]),v._v("服务器端开始协商"),_("code",[v._v("SSL")]),v._v("链接的安全等级，也就是加密等级。")]),v._v(" "),_("li",[v._v("客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。")]),v._v(" "),_("li",[_("code",[v._v("web")]),v._v("服务器通过自己的私钥解密出会话密钥。")]),v._v(" "),_("li",[_("code",[v._v("web")]),v._v("服务器通过会话密钥加密与客户端之间的通信。")])]),v._v(" "),_("h2",{attrs:{id:"https优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https优缺点"}},[v._v("#")]),v._v(" https优缺点")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("优点：")]),v._v(" "),_("ul",[_("li",[v._v("使用"),_("code",[v._v("HTTPS")]),v._v("协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；")]),v._v(" "),_("li",[_("code",[v._v("HTTPS")]),v._v("协议是由"),_("code",[v._v("SSL+HTTP")]),v._v("协议构建的可进行加密传输、身份认证的网络协议，要比"),_("code",[v._v("http")]),v._v("协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。")]),v._v(" "),_("li",[_("code",[v._v("HTTPS")]),v._v("是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。")]),v._v(" "),_("li",[v._v("谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等"),_("code",[v._v("HTTP")]),v._v("网站，采用"),_("code",[v._v("HTTPS")]),v._v("加密的网站在搜索结果中的排名将会更高”。")])])]),v._v(" "),_("li",[_("p",[v._v("缺点：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("https")]),v._v("握手阶段比较费时，会使页面加载时间延长"),_("code",[v._v("50%")]),v._v("，增加"),_("code",[v._v("10%~20%")]),v._v("的耗电。")]),v._v(" "),_("li",[_("code",[v._v("https")]),v._v("缓存不如"),_("code",[v._v("http")]),v._v("高效，会增加数据开销。")]),v._v(" "),_("li",[_("code",[v._v("SSL")]),v._v("证书也需要钱，功能越强大的证书费用越高。")]),v._v(" "),_("li",[_("code",[v._v("SSL")]),v._v("证书需要绑定"),_("code",[v._v("IP")]),v._v("，不能再同一个"),_("code",[v._v("ip")]),v._v("上绑定多个域名，"),_("code",[v._v("ipv4")]),v._v("资源支持不了这种消耗。")])])])]),v._v(" "),_("h2",{attrs:{id:"http和https的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http和https的区别"}},[v._v("#")]),v._v(" http和https的区别")]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("https")]),v._v("：是以安全为目标的"),_("code",[v._v("HTTP")]),v._v("通道，简单讲是"),_("code",[v._v("HTTP")]),v._v("的安全版，即"),_("code",[v._v("HTTP")]),v._v("下加入"),_("code",[v._v("SSL")]),v._v("层，"),_("code",[v._v("HTTPS")]),v._v("的安全基础是"),_("code",[v._v("SSL")]),v._v("，因此加密的详细内容就需要"),_("code",[v._v("SSL")]),v._v("。"),_("code",[v._v("https")]),v._v("协议的主要作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。")])]),v._v(" "),_("p",[_("code",[v._v("http")]),v._v("传输的数据都是未加密的，也就是明文的，网景公司设置了"),_("code",[v._v("SSL")]),v._v("协议来对"),_("code",[v._v("http")]),v._v("协议传输的数据进行加密处理，简单来说"),_("code",[v._v("https")]),v._v("协议是由"),_("code",[v._v("http")]),v._v("和"),_("code",[v._v("ssl")]),v._v("协议构建的可进行加密传输和身份认证的网络协议，比"),_("code",[v._v("http")]),v._v("协议的安全性更高。")]),v._v(" "),_("ul",[_("li",[v._v("主要的区别如下：\n"),_("ul",[_("li",[_("code",[v._v("Https")]),v._v("协议需要"),_("code",[v._v("ca")]),v._v("证书，费用较高。")]),v._v(" "),_("li",[_("code",[v._v("http")]),v._v("是超文本传输协议，信息是明文传输，"),_("code",[v._v("https")]),v._v("则是具有安全性的"),_("code",[v._v("ssl")]),v._v("加密传输协议。")]),v._v(" "),_("li",[v._v("使用不同的链接方式，端口也不同，一般而言，"),_("code",[v._v("http")]),v._v("协议的端口为"),_("code",[v._v("80")]),v._v("，"),_("code",[v._v("https")]),v._v("的端口为"),_("code",[v._v("443")])]),v._v(" "),_("li",[_("code",[v._v("http")]),v._v("的连接很简单，是无状态的；"),_("code",[v._v("HTTPS")]),v._v("协议是由"),_("code",[v._v("SSL+HTTP")]),v._v("协议构建的可进行加密传输、身份认证的网络协议，比"),_("code",[v._v("http")]),v._v("协议安全。")])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);